{"version":3,"sources":["../../src/region2d.js"],"names":["Region2D","infinite","empty","pInf","Number","POSITIVE_INFINITY","nInf","NEGATIVE_INFINITY","makeProtectedData","protectedData","expectedKey","actualKey","isArray","o","Array","makeRowPairGenerator","rows1","rows2","rowIndex1","rowIndex2","lastY","length","result","row1","row2","region","minY","Math","max","maxY","nextY1","nextY2","da","db","combineData","array1","array2","rowTransform","pairGenerator","lastResult","minX","maxX","hash","count","pair","resultRow","isEmpty","equals","push","getCount","rowBounds","getBounds","min","getHashCode","newRegionData","array","unionData","r1","r2","union","intersectData","intersect","xorData","xor","subtractData","subtract","doBoundsOverlap","data1","data2","makeRegionDataFromOneRect","rect","console","error","left","top","right","bottom","x","y","width","height","region1D","data","makeEmptyRegionData","getBoundsFromData","makeRects","i","l","row","getAsRects","isInfinite","arrayEquals","doesIntersectData","isPointInData","isPointIn","start","end","midpt","verifyRegion2DType","obj","privateKey","getData","_opaque","key","prototype","other","otherData","not","isFinite","isRectangular","doesIntersect","getRects","Region1D"],"mappings":"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","file":"region2d.js","sourcesContent":["import Region1D from './region1d';\r\n\r\n/**\r\n * Region2D objects are semi-opaque data structures that represent a 2-dimensional\r\n * set in the plane, described using axis-aligned rectangles of included points.\r\n * \r\n * ------------------------------------------------------------------------------------------------\r\n * \r\n * Region2D objects are capable of performing most major set-theoretic operations, including:\r\n * \r\n *   result = a.union(b);           // Return a new set that is the logical union of the two sets.\r\n *   result = a.intersect(b);       // Return a new set that is the logical intersection of the two sets.\r\n *   result = a.subtract(b);        // Return the logical subtraction of the two sets, i.e., the\r\n *                                  //   equivalent of a.union(b.not()), but computed more efficiently.\r\n *   result = a.xor(b);             // Return the exclusive-or of the two sets, i.e., those ranges\r\n *                                  //   which exist in one set or the other but not both.\r\n *   result = a.not();              // Return the logical complement of the set (which may include infinity).\r\n *   result = a.isEmpty();          // Return true/false if the set is empty.\r\n *   result = a.isFinite();         // Return true/false if the set is finite (doesn't stretch to infinity).\r\n *   result = a.isInfinite();       // Return true/false if the set stretches to infinity in any direction.\r\n *   result = a.isRectangular();    // Return true/false if the set can be described by a single rectangle.\r\n *   result = a.isPointIn(x, y);    // Return true if the given point is contained within the set.\r\n *   result = a.doesIntersect(b);   // Return true if the logical intersection of the two sets is nonempty.  This is\r\n *                                  //   more efficient than performing \"!a.intersect(b).isEmpty()\".\r\n *   result = a.equals(b);          // Return true if the sets are identical.\r\n *   result = a.getCount();         // Return the number of nonoverlapping rectangles that would describe this Region2D.\r\n *   result = a.getRects();\t\t\t// Return an array of nonoverlapping rectangles describing the Region2D.\r\n *   result = a.getBounds(b);       // Return a boundary rectangle containing all of the points of the Region2D.\r\n *\r\n * All Region2D operations are carefully written to be bounded in both time and\r\n * space, and all will run in no worse than O(n) or O(n+m) time.\r\n *\r\n * ------------------------------------------------------------------------------------------------\r\n * \r\n * Under the hood, this is partially implemented using Region1D.  Each Region2D consists of an\r\n * array of Region1D \"rows\" or \"bands,\" which represent sets of rectangles with identical\r\n * minY/maxY coordinates.  Each of the rows must be nonempty and must be unique (i.e., a successive\r\n * row's spans must not equal a previous row spans, if the maxY of the previous row equals the minY\r\n * of the successive row).\r\n * \r\n * Representing regions like this is how X Windows does it, and while this design may not always\r\n * result in the most optimized set of rectangles, the operations to work with these kinds of\r\n * regions are provably efficient:  This design trades space for time.\r\n * \r\n * As a rather nice side-effect of the design, calls to getRects() will always result in a set\r\n * of rectangles that go from top-to-bottom, left-to-right on the screen, which can be beneficial\r\n * in some rendering scenarios.\r\n * \r\n * This implementation also has performance optimizations to avoid combining regions when the\r\n * operations are meaningless or would result in the empty set, and there are various kinds of\r\n * boundary checks to early-out operations wherever possible.\r\n */\r\nconst Region2D = (function() {\r\n\r\n\tlet infinite, empty;\r\n\r\n\tconst\r\n\r\n\t//---------------------------------------------------------------------------------------------\r\n\t// Global constants.\r\n\t\r\n\t// Precache positive/negative infinity locally.\r\n\tpInf = Number.POSITIVE_INFINITY,\r\n\tnInf = Number.NEGATIVE_INFINITY,\r\n\r\n\t//---------------------------------------------------------------------------------------------\r\n\t// Helper functions.\r\n\r\n\t/**\r\n\t * Construct a wrapper around the given private data that makes it opaque except for \r\n\t * those with access to the 'expectedKey'.\r\n\t */\r\n\tmakeProtectedData = function(protectedData, expectedKey) {\r\n\t\treturn function(actualKey) {\r\n\t\t\tif (actualKey === expectedKey) return protectedData;\r\n\t\t\telse throw \"Illegal access\";\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Determine if the given object is an array. This is provided in newer JavaScript environs,\r\n\t * but is notably lacking in older ones.  We avoid a dependency on a huge package like CoreJS\r\n\t * by just defining the shim here.\r\n\t */\r\n\tisArray = function(o) {\r\n\t\treturn Array.isArray ? Array.isArray(o) : o instanceof Array;\r\n\t},\r\n\r\n\t//---------------------------------------------------------------------------------------------\r\n\t// Region internals.\r\n\r\n\t/**\r\n\t * Make a 'generator' function that, upon each invocation, will return the next\r\n\t * pair of rows that need to be combined, as the form { row1:, row2:, minY:, maxY: },\r\n\t * where row1 and row2 are the original Region1D objects, and minY and maxY should\r\n\t * be the Y coordinates of the resulting combined row.  This is actually a lot simpler\r\n\t * than it looks, but many separate cases need to be handled.\r\n\t * \r\n\t * On each separate invocation, the generator will return a new pair object until it\r\n\t * runs out of source rows, and then it will return null.\r\n\t */\r\n\tmakeRowPairGenerator = function(rows1, rows2) {\r\n\t\tlet rowIndex1 = 0;\r\n\t\tlet rowIndex2 = 0;\r\n\t\tlet lastY = nInf;\r\n\t\tlet empty = Region1D.empty;\r\n\r\n\t\treturn function() {\r\n\r\n\t\t\t//-------------------------------------------------------------------------------------\r\n\t\t\t// Step 1.  First, see if we've run out of data in either set.\r\n\r\n\t\t\tif (rowIndex1 >= rows1.length) {\r\n\t\t\t\t// No more left in rows1, so just take whatever's left of rows2.\r\n\t\t\t\tif (rowIndex2 >= rows2.length)\r\n\t\t\t\t\treturn null;\r\n\t\t\t\telse {\r\n\t\t\t\t\tconst result = {\r\n\t\t\t\t\t\trow1: empty, row2: rows2[rowIndex2].region,\r\n\t\t\t\t\t\tminY: Math.max(rows2[rowIndex2].minY, lastY), maxY: (lastY = rows2[rowIndex2].maxY)\r\n\t\t\t\t\t};\r\n\t\t\t\t\trowIndex2++;\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (rowIndex2 >= rows2.length) {\r\n\t\t\t\t// No more left in rows2, so just take whatever's left of rows1.\r\n\t\t\t\tconst result = {\r\n\t\t\t\t\trow1: rows1[rowIndex1].region, row2: empty,\r\n\t\t\t\t\tminY: Math.max(rows1[rowIndex1].minY, lastY), maxY: (lastY = rows1[rowIndex1].maxY)\r\n\t\t\t\t};\r\n\t\t\t\trowIndex1++;\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// We have remaining rows in both rows1 and rows2, so now we need\r\n\t\t\t\t// to do the general case.\r\n\t\t\t}\r\n\r\n\t\t\t//-------------------------------------------------------------------------------------\r\n\t\t\t// Step 2. Extract out the next row pair.  This is a somewhat-straightforward\r\n\t\t\t//   decision-tree approach, and is very fast, but since there are many possible\r\n\t\t\t//   cases, there are a lot of conditionals below to test for all of them.\r\n\r\n\t\t\tconst row1 = rows1[rowIndex1];\r\n\t\t\tconst row2 = rows2[rowIndex2];\r\n\t\t\tconst nextY1 = Math.max(row1.minY, lastY);\r\n\t\t\tconst nextY2 = Math.max(row2.minY, lastY);\r\n\r\n\t\t\tlet da, db, minY, maxY;\r\n\r\n\t\t\tif (nextY1 === nextY2) {\r\n\t\t\t\t// The A-side and B-side rows having a matching top edge.\r\n\t\t\t\tminY = nextY1;\r\n\r\n\t\t\t\t// These match the first half of the conditionals described below.\r\n\t\t\t\tda = row1.region, db = row2.region;\r\n\t\t\t\tif (row2.maxY < row1.maxY) {\r\n\t\t\t\t\tlastY = maxY = row2.maxY;\r\n\t\t\t\t\trowIndex2++;\r\n\t\t\t\t}\r\n\t\t\t\telse if (row2.maxY === row1.maxY) {\r\n\t\t\t\t\tlastY = maxY = row1.maxY;\r\n\t\t\t\t\trowIndex1++, rowIndex2++;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tlastY = maxY = row1.maxY;\r\n\t\t\t\t\trowIndex1++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (nextY1 < nextY2) {\r\n\t\t\t\t// The A-side row is strictly above the B-side row.\r\n\t\t\t\tminY = nextY1;\r\n\r\n\t\t\t\t// These match the second half of the conditionals described below.\r\n\t\t\t\tda = row1.region, db = empty;\r\n\t\t\t\tif (nextY2 >= row1.maxY) {\r\n\t\t\t\t\tlastY = maxY = row1.maxY;\r\n\t\t\t\t\trowIndex1++;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tlastY = maxY = nextY2;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// The B-side row is strictly above the A-side row.\r\n\t\t\t\tminY = nextY2;\r\n\r\n\t\t\t\t// These match the second half of the conditionals described below, inverted.\r\n\t\t\t\tda = empty, db = row2.region;\r\n\t\t\t\tif (nextY1 >= row2.maxY) {\r\n\t\t\t\t\tlastY = maxY = row2.maxY;\r\n\t\t\t\t\trowIndex2++;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tlastY = maxY = nextY1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//-------------------------------------------------------------------------------------\r\n\t\t\t// Step 3. Emit the result for this row pair.\r\n\r\n\t\t\tconst result = {\r\n\t\t\t\trow1: da, row2: db,\r\n\t\t\t\tminY: minY, maxY: maxY\r\n\t\t\t};\r\n\t\t\treturn result;\r\n\r\n\t\t\t/*\r\n\t\t\t\t//-------------------------------------------------------------------------------------\r\n\t\t\t\t// Step 2, in detail.  Both sides follow the same basic algorithm, as\r\n\t\t\t\t// explained below:\r\n\t\t\t\t//\r\n\t\t\t\t// Find the maxY, and iterate whichever side is the next one that requires\r\n\t\t\t\t// iteration (possibly both).\r\n\r\n\t\t\t\tif (ay === by) {\r\n\t\t\t\t\t// Top edges are equal, so we're consuming part or all of both rows.\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// Case 1.  +-------+   +-------+   <--- top equal\r\n\t\t\t\t\t//          |   a   |   |   b   |\r\n\r\n\t\t\t\t\t// Three possibilities:  rb.maxY is above, equal to, or below ra.maxY.\r\n\t\t\t\t\tif (rb.maxY < ra.maxY) {\r\n\t\t\t\t\t\t// Case 1a.  +-------+   +-------+   <--- top equal\r\n\t\t\t\t\t\t//           |   a   |   |   b   |\r\n\t\t\t\t\t\t//           |       |   +-------+   <--- bottom above\r\n\t\t\t\t\t\t//           +-------+\r\n\t\t\t\t\t\t// Consume all of rb, but only the top part of ra.\r\n\t\t\t\t\t\tlastY = maxY = rb.maxY;\r\n\t\t\t\t\t\tda = ra.region;\r\n\t\t\t\t\t\tdb = rb.region;\r\n\t\t\t\t\t\tib++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (rb.maxY === ra.maxY) {\r\n\t\t\t\t\t\t// Case 1b.  +-------+   +-------+   <--- top equal\r\n\t\t\t\t\t\t//           |   a   |   |   b   |\r\n\t\t\t\t\t\t//           +-------+   +-------+   <--- bottom equal\r\n\t\t\t\t\t\t// Consume both ra and rb.\r\n\t\t\t\t\t\tlastY = maxY = ra.maxY;\r\n\t\t\t\t\t\tda = ra.region;\r\n\t\t\t\t\t\tdb = rb.region;\r\n\t\t\t\t\t\tia++;\r\n\t\t\t\t\t\tib++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t// Case 1c.  +-------+   +-------+   <--- top equal\r\n\t\t\t\t\t\t//           |   a   |   |   b   |\r\n\t\t\t\t\t\t//           +-------+   |       |\r\n\t\t\t\t\t\t//                       +-------+   <--- bottom below\r\n\t\t\t\t\t\t// Consume all of ra, but only the top part of rb.\r\n\t\t\t\t\t\tlastY = maxY = ra.maxY;\r\n\t\t\t\t\t\tda = ra.region;\r\n\t\t\t\t\t\tdb = rb.region;\r\n\t\t\t\t\t\tia++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (by >= ra.maxY) {\r\n\t\t\t\t\t// Degenerate case:  by is past ra.maxY, so there\r\n\t\t\t\t\t// is no overlap at all.\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// Case 2.  +-------+   \r\n\t\t\t\t\t//          |   a   |\r\n\t\t\t\t\t//          +-------+\r\n\t\t\t\t\t//                      +-------+   <--- top entirely below a\r\n\t\t\t\t\t//                      |   b   |\r\n\t\t\t\t\t//                      +-------+\r\n\t\t\t\t\t// Consume all of ra, and none of rb.\r\n\t\t\t\t\tlastY = maxY = ra.maxY;\r\n\t\t\t\t\tda = ra.region;\r\n\t\t\t\t\tdb = empty;\r\n\t\t\t\t\tia++;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// Top edge of rb is below the top edge of ra, but there's definitely\r\n\t\t\t\t\t// overlap.  So we now need to decide how much overlap.\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// Case 3.  +-------+   \r\n\t\t\t\t\t//          |   a   |   +-------+   <--- top below\r\n\t\t\t\t\t//          |       |   |   b   |\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// Consume the next part of ra through by, but none of rb.\r\n\t\t\t\t\tlastY = maxY = by;\r\n\t\t\t\t\tda = ra.region;\r\n\t\t\t\t\tdb = empty;\r\n\t\t\t\t}\r\n\t\t\t*/\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Combine two regions together, returning a new region that is the result of having\r\n\t * combined them, using the provided rowTransform to mutate their individual rows.\r\n\t *\r\n\t * This spins over the rows of the regions in parallel, \"peeling off\" each successive\r\n\t * unique pair of rows with identical Y coordinates, and then invokes the transform\r\n\t * to perform the actual combination.  The transformed row is then added to the pile\r\n\t * of output rows, with a few interesting caveats to maintain the region invariants:\r\n\t *\r\n\t *   - We don't add a row that is identical to the previous row; we expand the previous row.\r\n\t *   - We don't add empty rows at all.\r\n\t *   - We do track the boundary min/max X coordinates as we go.\r\n\t *   - We compute the overall region hash as we go.\r\n\t *   - We only compute the boundary min/max Y coordinates after all rows are added.\r\n\t *\r\n\t * Neither input region may be empty.\r\n\t *\r\n\t * The result is always a valid region if the two input regions are valid regions.\r\n\t */\r\n\tcombineData = function(array1, array2, rowTransform) {\r\n\r\n\t\t// Make the generator that spits out pairs of rows to combine.\r\n\t\tconst pairGenerator = makeRowPairGenerator(array1, array2);\r\n\r\n\t\t// Spin over all the pairs of input rows, and combine them together to produce\r\n\t\t// the output region.\r\n\t\tlet lastResult = null;\r\n\t\tconst result = [];\r\n\t\tlet minX = pInf, maxX = nInf;\r\n\t\tlet hash = 0;\r\n\t\tlet count = 0;\r\n\t\tfor (let pair; pair = pairGenerator(); ) {\r\n\r\n\t\t\t// Perform the 1-dimensional version of the transform.\r\n\t\t\tconst resultRow = rowTransform(pair.row1, pair.row2);\r\n\r\n\t\t\t// If the result is empty, we don't add it.\r\n\t\t\tif (resultRow.isEmpty())\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t// If the result is the same as the previous row's result, and they're immediately\r\n\t\t\t// adjacent, then just expand the previous row: Don't add a new one.\r\n\t\t\tif (lastResult && resultRow.equals(lastResult.region) && lastResult.maxY == pair.minY) {\r\n\t\t\t\tlastResult.maxY = pair.maxY;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// New result row, and it's valid content, so add it to the result.\r\n\t\t\tresult.push(lastResult = {\r\n\t\t\t\tregion: resultRow,\r\n\t\t\t\tminY: pair.minY,\r\n\t\t\t\tmaxY: pair.maxY,\r\n\t\t\t});\r\n\r\n\t\t\t// Update the rectangle count.\r\n\t\t\tcount += resultRow.getCount();\r\n\r\n\t\t\t// Update the minima and maxima for this 2-D region based on the new row.\r\n\t\t\tconst rowBounds = resultRow.getBounds();\r\n\t\t\tif (rowBounds.min < minX) minX = rowBounds.min;\r\n\t\t\tif (rowBounds.max > maxX) maxX = rowBounds.max;\r\n\r\n\t\t\t// Update the hash (checksum) for the 2-D region based on the 1-D row hash.\r\n\t\t\thash *= 23;\r\n\t\t\thash += resultRow.getHashCode() | 0;\r\n\t\t\thash &= ~0;\r\n\t\t}\r\n\r\n\t\t// Finally, generate the 2-D region data itself.\r\n\t\tconst newRegionData = {\r\n\t\t\tarray: result,\r\n\t\t\tcount: count,\r\n\t\t\tminX: minX,\r\n\t\t\tminY: result.length ? result[0].minY : pInf,\r\n\t\t\tmaxX: maxX,\r\n\t\t\tmaxY: result.length ? result[result.length-1].maxY : nInf,\r\n\t\t\thash: hash\r\n\t\t};\r\n\t\treturn newRegionData;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Calculate the union of the given arrays of 2-D region data.\r\n\t * Returns a new array that contains the 2-D union.\r\n\t */\r\n\tunionData = (array1, array2) => combineData(array1, array2, (r1, r2) => r1.union(r2)),\r\n\r\n\t/**\r\n\t * Calculate the intersection of the given arrays of 2-D region data.\r\n\t * Returns a new array that contains the 2-D intersection.\r\n\t */\r\n\tintersectData = (array1, array2) => combineData(array1, array2, (r1, r2) => r1.intersect(r2)),\r\n\r\n\t/**\r\n\t * Calculate the exclusive-or of the given arrays of 2-D region data.\r\n\t * Returns a new array that contains the 2-D exclusive-or.\r\n\t */\r\n\txorData = (array1, array2) => combineData(array1, array2, (r1, r2) => r1.xor(r2)),\r\n\r\n\t/**\r\n\t * Calculate the difference of the given arrays of 2-D region data.\r\n\t * Returns a new array that contains the 2-D difference.\r\n\t */\r\n\tsubtractData = (array1, array2) => combineData(array1, array2, (r1, r2) => r1.subtract(r2)),\r\n\t\r\n\t/**\r\n\t * Determine if the bounding rectangles of each region actually overlap.  If they\r\n\t * don't overlap, we can often treat region operations as special degenerate cases.\r\n\t * This runs in O(1) time.\r\n\t */\r\n\tdoBoundsOverlap = function(data1, data2) {\r\n\t\treturn !(data1.minX > data2.maxX\r\n\t\t\t|| data1.maxX < data2.minX\r\n\t\t\t|| data1.minY > data2.maxY\r\n\t\t\t|| data1.maxY < data2.minY);\r\n\t},\r\n\t\r\n\t/**\r\n\t * Make region data from a single rectangle, in one of the three major rectangle forms:\r\n\t *     - An object with { x:, y:, width:, height: } properties.\r\n\t *     - An object with { left:, top:, right:, bottom: } properties.\r\n\t *     - An array with [x, y, width, height] values.\r\n\t * \r\n\t * This is fairly straightforward, and runs in O(1) time.\r\n\t */\r\n\tmakeRegionDataFromOneRect = function(rect) {\r\n\r\n\t\t// Calculate the actual rectangle coordinates from whatever object was passed in.\r\n\t\tlet minX, maxX, minY, maxY;\r\n\t\tif (isArray(rect)) {\r\n\t\t\tif (rect.length !== 4) {\r\n\t\t\t\tconsole.error(\"Cannot construct a Region2D; invalid rectangle data.\");\r\n\t\t\t\tthrow \"Data error\";\r\n\t\t\t}\r\n\t\t\tminX = Number(rect[0]), minY = Number(rect[1]);\r\n\t\t\tmaxX = Number(rect[2]), maxY = Number(rect[3]);\r\n\t\t}\r\n\t\telse if (\"left\" in rect) {\r\n\t\t\tminX = Number(rect.left), minY = Number(rect.top);\r\n\t\t\tmaxX = Number(rect.right), maxY = Number(rect.bottom);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tminX = Number(rect.x), minY = Number(rect.y);\r\n\t\t\tmaxX = minX + Number(rect.width), maxY = minY + Number(rect.height);\r\n\t\t}\r\n\r\n\t\t// Validate the rectangle data.\r\n\t\tif (maxX <= minX || maxY <= minY) {\r\n\t\t\tconsole.error(\"Cannot construct a Region2D from a rectangle of zero or negative size.\");\r\n\t\t\tthrow \"Data error\";\r\n\t\t}\r\n\r\n\t\t// Construct the new row containing that rectangle.\r\n\t\tconst region1D = new Region1D([minX, maxX]);\r\n\r\n\t\t// Now make the actual region data for this single-rect region.\r\n\t\tconst data = {\r\n\t\t\tarray: [ {\r\n\t\t\t\tregion: region1D,\r\n\t\t\t\tminY: minY,\r\n\t\t\t\tmaxY: maxY\r\n\t\t\t} ],\r\n\t\t\tcount: 1,\r\n\t\t\tminX: minX,\r\n\t\t\tminY: minY,\r\n\t\t\tmaxX: maxX,\r\n\t\t\tmaxY: maxY,\r\n\t\t\thash: region1D.getHashCode()\r\n\t\t};\r\n\r\n\t\treturn data;\r\n\t},\r\n\r\n\t/**\r\n\t * Construct an empty region consisting of no rectangles at all.\r\n\t */\r\n\tmakeEmptyRegionData = function() {\r\n\t\treturn {\r\n\t\t\tarray: [ ],\r\n\t\t\tcount: 0,\r\n\t\t\tminX: pInf,\r\n\t\t\tminY: pInf,\r\n\t\t\tmaxX: nInf,\r\n\t\t\tmaxY: nInf,\r\n\t\t\thash: 0\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Create a simple rectangle from the given region's internal bounding rect.\r\n\t */\r\n\tgetBoundsFromData = function(data) {\r\n\t\treturn {\r\n\t\t\tx: data.minX,\r\n\t\t\ty: data.minY,\r\n\t\t\twidth: data.maxX - data.minX,\r\n\t\t\theight: data.maxY - data.minY,\r\n\t\t\tleft: data.minX,\r\n\t\t\ttop: data.minY,\r\n\t\t\tright: data.maxX,\r\n\t\t\tbottom: data.maxY\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Get all of the rectangle data for this entire region.\r\n\t */\r\n\tmakeRects = function(array) {\r\n\t\tconst result = [];\r\n\t\tfor (let i = 0, l = array.length; i < l; i++) {\r\n\t\t\tconst row = array[i];\r\n\t\t\trow.region.getAsRects(row.minY, row.maxY, result);\r\n\t\t}\r\n\t\treturn result;\r\n\t},\r\n\r\n\t/**\r\n\t * Determine whether this region stretches to infinity in any direction.\r\n\t */\r\n\tisInfinite = function(data) {\r\n\t\treturn data.minX === nInf || data.minY === nInf\r\n\t\t\t|| data.maxX === pInf || data.maxY === pInf;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Compare the Region1D data found in each array instance to each other for equality.\r\n\t */\r\n\tarrayEquals = function(array1, array2) {\r\n\t\tif (array1.length != array2.length) return false;\r\n\t\tfor (let i = 0, l = array1.length; i < l; i++) {\r\n\t\t\tif (!array1[i].equals(array2[i])) return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t},\r\n\r\n\t/**\r\n\t * Determine if the data of region1 intersects the data of region2, and do so more efficiently\r\n\t * than simply performing \"!a.intersect(b).isEmpty()\".\r\n\t */\r\n\tdoesIntersectData = function(data1, data2) {\r\n\t\t// TODO: Implement this better than the quick-and-dirty solution below.  Ideally,\r\n\t\t//    this should just test the data and early-out on the first hit, rather than\r\n\t\t//    actually *doing* all the work and then discarding the result.\r\n\t\treturn !!intersectData(data1.array, data2.array).array.length;\r\n\t},\r\n\r\n\t/**\r\n\t * Determine if the given point lies within the given region data.  This first performs\r\n\t * some easy boundary checks, then efficiently finds the matching row (if any), and then\r\n\t * invokes Region1D.isPointIn() to efficiently answer the question for real.  This runs in\r\n\t * O(lg n) time, where 'n' is the number of rectangles in the region.\r\n\t */\r\n\tisPointInData = function(data, x, y) {\r\n\t\tconst array = data.array;\r\n\r\n\t\t// It can't be in the empty set.\r\n\t\tif (!array.length) return false;\r\n\t\t\r\n\t\t// If it's outside the bounds, it's definitely not in.\r\n\t\tif (y < data.minY || y > data.maxY\r\n\t\t\t|| x < data.minX || x > data.maxX) return false;\r\n\t\t\r\n\t\tif (array.length <= 5) {\r\n\t\t\t// Spin over all the rows in a simple linear search.\r\n\t\t\tfor (let i = 0, l = array.length; i < l; i += 2) {\r\n\t\t\t\tif (y >= array[i].minY && y < array[i].maxY) {\r\n\t\t\t\t\t// Found the row.\r\n\t\t\t\t\treturn array[i].region.isPointIn(x);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Binary search to find the row that y is within.\r\n\t\t\tlet start = 0, end = array.length;\r\n\t\t\twhile (start < end) {\r\n\t\t\t\tconst midpt = ((start + end) / 2) & ~0;\r\n\t\t\t\tconst row = array[midpt];\r\n\t\t\t\tif (y >= row.minY && y < row.maxY) {\r\n\t\t\t\t\t// Found the row, so see if 'x' lies within its spans.\r\n\t\t\t\t\treturn row.region.isPointIn(x);\r\n\t\t\t\t}\r\n\t\t\t\telse if (y < row.minY) {\r\n\t\t\t\t\tend = midpt;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tstart = midpt + 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Check to ensure that the given object is actually a Region2D, and abort if it is not.\r\n\t */\r\n\tverifyRegion2DType = function(obj) {\r\n\t\tif (!(obj instanceof Region2D)) {\r\n\t\t\tconsole.error(\"Object must be a Region2D instance.\");\r\n\t\t\tthrow \"Type error\";\r\n\t\t}\r\n\t},\r\n\r\n\t//---------------------------------------------------------------------------------------------\r\n\t// Public construction interface.\r\n\t\r\n\t/**\r\n\t * A special private object used to flag internal constructions in such a way that\r\n\t * external callers' data must be validated, but internal data can skip those checks.\r\n\t */\r\n\tprivateKey = {},\r\n\r\n\t/**\r\n\t * Access the internal data, if this is an allowed thing to do.\r\n\t */\r\n\tgetData = function(region) {\r\n\t\treturn region._opaque(privateKey);\r\n\t},\r\n\r\n\t/**\r\n\t * Construct a 2-D region either from either nothing or from the given rectangle.\r\n\t * \r\n\t * Usage:\r\n\t *     var empty = new Region2d();\r\n\t *     var rectRegion = new Region2d(rect);\r\n\t * \r\n\t * The rectangle may be expressed as any of the following three forms:\r\n\t *     - An object with { x:, y:, width:, height: } properties.\r\n\t *     - An object with { left:, top:, right:, bottom: } properties.\r\n\t *     - An array with [x, y, width, height] values.\r\n\t * \r\n\t * Alternative internal invocation:\r\n\t *     var region = new Region2d(regionData, privateKey);\r\n\t */\r\n\tRegion2D = function(rect, key) {\r\n\t\tconst data = (key === privateKey) ? rect\r\n\t\t\t: (typeof rect !== 'undefined') ? makeRegionDataFromOneRect(rect)\r\n\t\t\t: makeEmptyRegionData();\r\n\r\n\t\tthis._opaque = makeProtectedData(data, privateKey);\r\n\t};\r\n\r\n\t/**\r\n\t * The region's prototype contains helpers that simply invoke the private operations\r\n\t * to do all the hard work.\r\n\t */\r\n\tRegion2D.prototype = {\r\n\t\tunion: function(other) {\r\n\t\t\tverifyRegion2DType(other);\r\n\t\t\tconst data = getData(this), otherData = getData(other);\r\n\t\t\treturn new Region2D(unionData(data.array, otherData.array), privateKey);\r\n\t\t},\r\n\t\tintersect: function(other) {\r\n\t\t\tverifyRegion2DType(other);\r\n\t\t\tconst data = getData(this), otherData = getData(other);\r\n\t\t\tif (!doBoundsOverlap(data, otherData))\r\n\t\t\t\treturn empty;\r\n\t\t\treturn new Region2D(intersectData(data.array, otherData.array), privateKey);\r\n\t\t},\r\n\t\tsubtract: function(other) {\r\n\t\t\tverifyRegion2DType(other);\r\n\t\t\tconst data = getData(this), otherData = getData(other);\r\n\t\t\tif (!doBoundsOverlap(data, otherData))\r\n\t\t\t\treturn data;\r\n\t\t\treturn new Region2D(subtractData(data.array, otherData.array), privateKey);\r\n\t\t},\r\n\t\txor: function(other) {\r\n\t\t\tverifyRegion2DType(other);\r\n\t\t\tconst data = getData(this), otherData = getData(other);\r\n\t\t\treturn new Region2D(xorData(data.array, otherData.array), privateKey);\r\n\t\t},\r\n\t\tnot: function() {\r\n\t\t\t// Lazy implementation of 'not': Simply 'xor' with an infinite region.\r\n\t\t\t// A better implementation would take advantage of the efficient Region1d#not() method.\r\n\t\t\tconst data = getData(this);\r\n\t\t\treturn new Region2D(xorData(data.array, infinite.array), privateKey);\r\n\t\t},\r\n\t\tisEmpty: function() {\r\n\t\t\treturn !getData(this).array.length;\r\n\t\t},\r\n\t\tisInfinite: function() {\r\n\t\t\treturn isInfinite(getData(this));\r\n\t\t},\r\n\t\tisFinite: function() {\r\n\t\t\treturn !isInfinite(getData(this));\r\n\t\t},\r\n\t\tisRectangular: function() {\r\n\t\t\treturn getData(this).count === 1;\r\n\t\t},\r\n\t\tdoesIntersect: function(other) {\r\n\t\t\tverifyRegion2DType(other);\r\n\t\t\treturn doesIntersectData(getData(this));\r\n\t\t},\r\n\t\tisPointIn: function(x, y) {\r\n\t\t\treturn isPointInData(getData(this), Number(x), Number(y));\r\n\t\t},\r\n\t\tequals: function(other) {\r\n\t\t\tverifyRegion2DType(other);\r\n\t\t\tconst data = getData(this), otherData = getData(other);\r\n\t\t\tif (data.hash != otherData.hash\r\n\t\t\t\t|| data.count !== otherData.count) return false;\r\n\t\t\treturn arrayEquals(data.array, otherData.array);\r\n\t\t},\r\n\t\tgetCount: function() {\r\n\t\t\treturn getData(this).count;\r\n\t\t},\r\n\t\tgetRects: function() {\r\n\t\t\treturn makeRects(getData(this).array);\r\n\t\t},\r\n\t\tgetBounds: function() {\r\n\t\t\treturn getBoundsFromData(getData(this));\r\n\t\t},\r\n\t\tgetHashCode: function() {\r\n\t\t\treturn getData(this).hash;\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * A reusable infinite instance.\r\n\t */\r\n\tRegion2D.infinite = infinite = new Region2D([nInf, nInf, pInf, pInf]);\r\n\r\n\t/**\r\n\t * A reusable empty instance.\r\n\t */\r\n\tRegion2D.empty = empty = new Region2D();\r\n\t\r\n\treturn Region2D;\r\n})();\r\n\r\nexport default Region2D;\r\nexport { Region1D, Region2D };\r\n"]}