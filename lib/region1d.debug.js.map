{"version":3,"sources":["../../src/region1d.js"],"names":["Region1D","pInf","Number","POSITIVE_INFINITY","nInf","NEGATIVE_INFINITY","makeProtectedData","protectedData","expectedKey","actualKey","isArray","o","Array","makeCoordinateGenerator","array1","array2","i1","i2","length","x","kind","src","combineData","op","getNext","depth1","depth2","state","lastState","coord","result","nextCoord","push","unionData","intersectData","xorData","subtractData","doesIntersectData","isPointInData","array","i","l","start","end","index","midpt","value","notData","newArray","arrayEquals","makeRects","minY","maxY","height","minX","maxX","y","width","left","top","right","bottom","makeRawSpans","makeHashCode","hash","verifyRegion1DType","obj","console","error","validateData","typeError","typeErrorMsg","dataError","dataErrorMsg","prev","cur","privateKey","getData","region","_opaque","key","min","max","prototype","union","other","data","otherData","intersect","subtract","xor","not","isEmpty","getCount","doesIntersect","isPointIn","equals","getRawSpans","getAsRects","destArray","getBounds","getHashCode","empty"],"mappings":"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","file":"region1d.js","sourcesContent":["/**\r\n * Region1D objects are semi-opaque data structures that represent a 1-dimensional\r\n * set on the number line, described using \"spans\" of included points.\r\n *\r\n * ------------------------------------------------------------------------------------------------\r\n *\r\n * Each span in the region has an inclusive start and an exclusive end.  Spans may\r\n * not overlap, and always must appear in sorted order.  So, for example, consider\r\n * this set:\r\n *\r\n *           #####  ####      ###########       ####     #\r\n *        |----+----|----+----|----+----|----+----|----+----|\r\n *       0     5   10   15   20   25   30   35   40   45   50\r\n *\r\n * This set (inclusively) contains the numbers 3-7, 10-13, 20-30, 38-41, and 47.\r\n * Its Region1D representation (using only integer values) would therefore\r\n * consist of these ranges:\r\n *\r\n *   [3,8); [10,14); [20,31); [38,42); [47,48)\r\n *\r\n * And thus the resulting data array stored by the Region1D object would be:\r\n *\r\n *   [3, 8, 10, 14, 20, 31, 38, 42, 47, 48]\r\n *\r\n * Note that when you construct a Region1D, you *must* provide the data array\r\n * in sorted order, or the Region1D's constraints will be violated.\r\n *\r\n * ------------------------------------------------------------------------------------------------\r\n *\r\n * Region1Ds provide many operations that can be used to manipulate their\r\n * data as formal sets, including:\r\n *\r\n *   result = a.union(b);           // Return a new set that is the logical union of the two sets.\r\n *   result = a.intersect(b);       // Return a new set that is the logical intersection of the two sets.\r\n *   result = a.subtract(b);        // Return the logical subtraction of the two sets, i.e., the\r\n *                                  //   equivalent of a.union(b.not()), but computed more efficiently.\r\n *   result = a.xor(b);             // Return the exclusive-or of the two sets, i.e., those ranges\r\n *                                  //   which exist in one set or the other but not both.\r\n *   result = a.not();              // Return the logical complement of the set (which may include infinity).\r\n *   result = a.isEmpty();          // Return true/false if the set is empty.\r\n *   result = a.isPointIn(x);       // Return true if the given coordinate is contained within the set.\r\n *   result = a.doesIntersect(b);   // Return true if the logical intersection of the two sets is nonempty.  This is\r\n *                                  //   more efficient than performing \"!a.intersect(b).isEmpty()\".\r\n *   result = a.equals(b);          // Return true if the sets are identical.\r\n *   result = a.getBounds(b);       // Return { min:, max: } of the Region1D.\r\n *   result = a.getAsRects(minY, maxY); // Return an array of { x:, y:, width:, height: } rectangles describing the Region1D.\r\n *   result = a.getRawSpans();      // Return a raw array of numbers, the same kind that was used to construct the Region1D.\r\n *\r\n * All Region1D operations are carefully written to be bounded in both time and\r\n * space, and all will run in no worse than O(n) or O(n+m) time.\r\n */\r\nconst Region1D = (function() {\r\n\t\r\n\tconst\r\n\r\n\t//---------------------------------------------------------------------------------------------\r\n\t// Global constants.\r\n\t\r\n\t// Precache positive/negative infinity locally.\r\n\tpInf = Number.POSITIVE_INFINITY,\r\n\tnInf = Number.NEGATIVE_INFINITY,\r\n\r\n\t//---------------------------------------------------------------------------------------------\r\n\t// Helper functions.\r\n\r\n\t/**\r\n\t * Construct a wrapper around the given private data that makes it opaque except for \r\n\t * those with access to the 'expectedKey'.\r\n\t */\r\n\tmakeProtectedData = function(protectedData, expectedKey) {\r\n\t\treturn function(actualKey) {\r\n\t\t\tif (actualKey === expectedKey) return protectedData;\r\n\t\t\telse throw \"Illegal access\";\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Determine if the given object is an array. This is provided in newer JavaScript environs,\r\n\t * but is notably lacking in older ones.  We avoid a dependency on a huge package like CoreJS\r\n\t * by just defining the shim here.\r\n\t */\r\n\tisArray = function(o) {\r\n\t\treturn Array.isArray ? Array.isArray(o) : o instanceof Array;\r\n\t},\r\n\t\r\n\t//---------------------------------------------------------------------------------------------\r\n\t// 1-D raw-data-manipulation functions.\r\n\r\n\t/**\r\n\t * Make a function that generates successive lowest values from each of the two given arrays.\r\n\t */\r\n\tmakeCoordinateGenerator = function(array1, array2) {\r\n\t\tlet i1 = 0, i2 = 0;\r\n\t\t\r\n\t\t// Get the next coordinate with the lowest value from either array, keeping\r\n\t\t// track of whether it is a begin (+1) or end (-1) coordinate of its span.  O(1).\r\n\t\treturn function() {\r\n\t\t\tif (i1 >= array1.length && i2 >= array2.length)\r\n\t\t\t\treturn null;\r\n\t\t\telse if (i1 >= array1.length)\r\n\t\t\t\treturn { x: array2[i2], kind: i2++ & 1 ? -1 : +1, src: 2 };\r\n\t\t\telse if (i2 >= array2.length || array1[i1] < array2[i2])\r\n\t\t\t\treturn { x: array1[i1], kind: i1++ & 1 ? -1 : +1, src: 1 };\r\n\t\t\telse\r\n\t\t\t\treturn { x: array2[i2], kind: i2++ & 1 ? -1 : +1, src: 2 };\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Calculate the combination of the given (sorted!) arrays of 1-D region data.\r\n\t * Returns a new array that contains the 1-D combination.\r\n\t */\r\n\tcombineData = function(array1, array2, op) {\r\n\r\n\t\t// Special case: Nothin' from nothin' gives nothin'.\r\n\t\tif (!array1.length && !array2.length)\r\n\t\t\treturn [];\r\n\r\n\t\t// Get the next coordinate with the lowest value from either array, keeping\r\n\t\t// track of whether it is a begin (+1) or end (-1) coordinate of its span.  O(1).\r\n\t\tconst getNext = makeCoordinateGenerator(array1, array2);\r\n\t\t\r\n\t\tlet depth1 = 0, depth2 = 0;\r\n\t\tlet state = 0, lastState = 0;\r\n\r\n\t\t// Do whatever needs to happen at the very first coordinate.\r\n\t\tlet coord = getNext();\r\n\t\t\r\n\t\t// Process all of the coordinates until both arrays are empty, collecting\r\n\t\t// new spans in the 'result' array.  O(n+m).\r\n\t\tconst result = [];\r\n\t\tdo {\r\n\t\t\t// Do whatever happens at this coordinate.\r\n\t\t\tif (coord.src === 1) depth1 += coord.kind;\r\n\t\t\telse depth2 += coord.kind;\r\n\r\n\t\t\t// Process any subsequent coordinates at the same 'x' offset,\r\n\t\t\t// also collecting the one after it.\r\n\t\t\tlet nextCoord;\r\n\t\t\twhile ((nextCoord = getNext()) && nextCoord.x === coord.x) {\r\n\t\t\t\tif (nextCoord.src === 1) depth1 += nextCoord.kind;\r\n\t\t\t\telse depth2 += nextCoord.kind;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Change the state to match whatever happened here.\r\n\t\t\tlastState = state;\r\n\t\t\tstate = op(depth1, depth2);\r\n\r\n\t\t\t// If we entered/exited a new span, emit a start/end X value.\r\n\t\t\tif (state !== lastState) {\r\n\t\t\t\tresult.push(coord.x);\r\n\t\t\t}\r\n\r\n\t\t\tcoord = nextCoord;\r\n\t\t} while (coord);\r\n\r\n\t\treturn result;\r\n\t},\r\n\r\n\t/**\r\n\t * Calculate the union of the given arrays of 1-D region data.\r\n\t * Returns a new array that contains the 1-D union.\r\n\t */\r\n\tunionData = (array1, array2) => combineData(array1, array2,\r\n\t\t(depth1, depth2) => (depth1 | depth2)\r\n\t),\r\n\r\n\t/**\r\n\t * Calculate the intersection of the given arrays of 1-D region data.\r\n\t * Returns a new array that contains the 1-D intersection.\r\n\t */\r\n\tintersectData = (array1, array2) => combineData(array1, array2,\r\n\t\t(depth1, depth2) => (depth1 & depth2)\r\n\t),\r\n\r\n\t/**\r\n\t * Calculate the exclusive-or of the given arrays of 1-D region data.\r\n\t * Returns a new array that contains the 1-D exclusive-or.\r\n\t */\r\n\txorData = (array1, array2) => combineData(array1, array2,\r\n\t\t(depth1, depth2) => (depth1 ^ depth2)\r\n\t),\r\n\r\n\t/**\r\n\t * Calculate the difference of the given arrays of 1-D region data.\r\n\t * Returns a new array that contains the 1-D difference.\r\n\t */\r\n\tsubtractData = (array1, array2) => combineData(array1, array2,\r\n\t\t(depth1, depth2) => (depth1 & ~depth2)\r\n\t),\r\n\r\n\t/**\r\n\t * Calculate whether the given arrays of 1-D region data intersect.\r\n\t * This requires constant memory, but it may take O(n+m) time.\r\n\t * Returns true or false.\r\n\t */\r\n\tdoesIntersectData = function(array1, array2) {\r\n\t\t\r\n\t\t// If either is empty, there's no intersection.\r\n\t\tif (!array1.length || !array2.length) return false;\r\n\t\t\r\n\t\t// If all of the spans of one are before all of the spans of another, there's no intersection.\r\n\t\tif (array1[array1.length - 1] < array2[0]\r\n\t\t\t|| array2[array2.length - 1] < array1[0]) return false;\r\n\t\t\t\r\n\t\t// Test all the spans against each other.\r\n\t\tlet depth1 = 0, depth2 = 0;\r\n\t\tconst getNext = makeCoordinateGenerator(array1, array2);\r\n\r\n\t\t// Do whatever needs to happen at the very first coordinate.\r\n\t\tlet coord = getNext();\r\n\r\n\t\tdo {\r\n\t\t\t// Do whatever happens at this coordinate.\r\n\t\t\tif (coord.src === 1) depth1 += coord.kind;\r\n\t\t\telse depth2 += coord.kind;\r\n\r\n\t\t\t// Process any subsequent coordinates at the same 'x' offset,\r\n\t\t\t// also collecting the one after it.\r\n\t\t\tlet nextCoord;\r\n\t\t\twhile ((nextCoord = getNext()) && nextCoord.x === coord.x) {\r\n\t\t\t\tif (nextCoord.src === 1) depth1 += nextCoord.kind;\r\n\t\t\t\telse depth2 += nextCoord.kind;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Change the state to match whatever happened here.\r\n\t\t\tif (depth1 & depth2) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\tcoord = nextCoord;\r\n\t\t} while (coord);\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\t/**\r\n\t * Determine whether the given point lies within the spans of the Region1D data.\r\n\t */\r\n\tisPointInData = function(array, x) {\r\n\t\t// It can't be in the empty set.\r\n\t\tif (!array.length) return false;\r\n\t\t\r\n\t\t// If it's outside the bounds, it's not anywhere within any of the spans.\r\n\t\tif (x < array[0] || x > array[array.length - 1]) return false;\r\n\t\t\r\n\t\tif (array.length <= 8) {\r\n\t\t\t// Spin over all the spans in a simple linear search.\r\n\t\t\tfor (let i = 0, l = array.length; i < l; i += 2) {\r\n\t\t\t\tif (x >= array[i] && x < array[i+1]) return true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Binary search to find the array index that x is either after or at.\r\n\t\t\tlet start = 0, end = array.length;\r\n\t\t\tlet index = 0;\r\n\t\t\twhile (start < end) {\r\n\t\t\t\tconst midpt = ((start + end) / 2) & ~0;\r\n\t\t\t\tconst value = array[midpt];\r\n\t\t\t\tif (x === value) {\r\n\t\t\t\t\tindex = midpt;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\telse if (x < value) {\r\n\t\t\t\t\tend = midpt;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tindex = midpt;\r\n\t\t\t\t\tstart = midpt + 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// 'index' now is the closest value at or before 'x', so we just need to see if\r\n\t\t\t// it's an odd or even array index to know if 'x' is inside the span or outside it.\r\n\t\t\treturn !(index & 1);\r\n\t\t}\r\n\t},\r\n\t\r\n\t/**\r\n\t * Calculate a complement of the 1-D (sorted!) region data.\r\n\t * This is easy:\r\n\t *    If it starts with -Inf, remove that; otherwise, prepend -Inf.\r\n\t *    If it ends with +Inf, remove that; otherwise, append +Inf.\r\n\t * Returns a new array that contains the 1D complement.\r\n\t */\r\n\tnotData = function(array) {\r\n\t\tconst newArray = [];\r\n\r\n\t\tlet src = 0;\r\n\r\n\t\tif (!array.length) {\r\n\t\t\tnewArray.push(nInf);\r\n\t\t\tnewArray.push(pInf);\r\n\t\t\treturn newArray;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (array[src] != nInf) newArray.push(nInf);\r\n\t\t\telse src++;\r\n\t\t}\r\n\r\n\t\twhile (src < array.length - 1) {\r\n\t\t\tnewArray.push(array[src++]);\r\n\t\t}\r\n\r\n\t\tif (array[src] != pInf) {\r\n\t\t\tnewArray.push(array[src++]);\r\n\t\t\tnewArray.push(pInf);\r\n\t\t}\r\n\t\t\r\n\t\treturn newArray;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Determine if two arrays of (sorted!) 1-D region data are equivalent.\r\n\t * Returns true if they are the same, false if they are different.\r\n\t */\r\n\tarrayEquals = function(array1, array2) {\r\n\t\tif (array1.length != array2.length) return false;\r\n\t\tfor (let i = 0, l = array1.length; i < l; i++) {\r\n\t\t\tif (array1[i] != array2[i]) return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t},\r\n\r\n\t/**\r\n\t * Transform a set of 1-D region data into an array of rectangles with\r\n\t * the given same y and height values.\r\n\t *\r\n\t * Returns a new array that contains rectangles of the form { x:, y:, width:, height:, left:, top:, right:, bottom: }.\r\n\t */\r\n\tmakeRects = function(array, minY, maxY, result) {\r\n\t\tconst height = maxY - minY;\r\n\t\t\r\n\t\tfor (let i = 0, l = array.length; i < l; i += 2) {\r\n\t\t\tconst minX = array[i  ];\r\n\t\t\tconst maxX = array[i+1];\r\n\t\t\tresult.push({\r\n\t\t\t\tx: minX, y: minY, width: maxX - minX, height:height,\r\n\t\t\t\tleft: minX, top: minY, right: maxX, bottom: maxY\r\n\t\t\t});\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t},\r\n\r\n\t/**\r\n\t * Clone a set of 1-D region data into a raw array.\r\n\t * Returns a new array that contains pairs of points.\r\n\t */\r\n\tmakeRawSpans = function(array) {\r\n\t\tconst result = [];\r\n\t\tfor (let i = 0, l = array.length; i < l; i += 2) {\r\n\t\t\tresult.push(array[i  ]);\r\n\t\t\tresult.push(array[i+1]);\r\n\t\t}\r\n\t\treturn result;\r\n\t},\r\n\r\n\t/**\r\n\t * Calculate a hash that (loosely) describes the given Region1D of data, so that we\r\n\t * can readily tell whether it is different from another.\r\n\t */\r\n\tmakeHashCode = function(array) {\r\n\t\tlet hash = 0;\r\n\t\tfor (let i = 0, l = array.length; i < l; i++) {\r\n\t\t\thash *= 23;\r\n\t\t\thash += array[i] | 0;\r\n\t\t\thash &= ~0;\r\n\t\t}\r\n\t\treturn hash;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Check to ensure that the given object is actually a Region1D, and abort if it is not.\r\n\t */\r\n\tverifyRegion1DType = function(obj) {\r\n\t\tif (!(obj instanceof Region1D)) {\r\n\t\t\tconsole.error(\"Object must be a Region1D instance.\");\r\n\t\t\tthrow \"Type error\";\r\n\t\t}\r\n\t},\r\n\t\r\n\t/**\r\n\t * Check the given data to make sure that it consists of an array of ordered pairs\r\n\t * of span start/end points.\r\n\t */\r\n\tvalidateData = function(array) {\r\n\t\r\n\t\tconst typeError = \"Type error\";\r\n\t\tconst typeErrorMsg = \"Expected an ordered array of numeric start/end pairs.\";\r\n\t\tconst dataError = \"Data error\";\r\n\t\tconst dataErrorMsg = \"Array start/end pairs are not in strictly ascending order.\";\r\n\r\n\t\t// Make sure it's an array of even length.\r\n\t\tif (!isArray(array) || (array.length & 1)) {\r\n\t\t\tconsole.error(typeErrorMsg);\r\n\t\t\tthrow typeError;\r\n\t\t}\r\n\r\n\t\t// Empty array is always valid.\r\n\t\tif (array.length == 0) return;\r\n\r\n\t\t// Get the first entry, and make sure it's a number.\r\n\t\tlet prev = array[0];\r\n\t\tif (typeof prev !== 'number') {\r\n\t\t\tconsole.error(typeErrorMsg);\r\n\t\t\tthrow typeError;\r\n\t\t}\r\n\r\n\t\t// Check each successive entry to make sure that it's (A) a number and (B) strictly\r\n\t\t// greater than the entry before it.\r\n\t\tfor (let i = 1, l = array.length; i < l; i++) {\r\n\t\t\tlet cur = array[i];\r\n\t\t\tif (typeof cur !== 'number') {\r\n\t\t\t\tconsole.error(typeErrorMsg);\r\n\t\t\t\tthrow typeError;\r\n\t\t\t}\r\n\t\t\tif (cur <= prev) {\r\n\t\t\t\tconsole.error(dataErrorMsg);\r\n\t\t\t\tthrow dataError;\r\n\t\t\t}\r\n\t\t\tprev = cur;\r\n\t\t}\r\n\t},\r\n\t\r\n\t//---------------------------------------------------------------------------------------------\r\n\t// Public interface.\r\n\t\r\n\t/**\r\n\t * A special private object used to flag internal constructions in such a way that\r\n\t * external callers' data must be validated, but internal data can skip those checks.\r\n\t */\r\n\tprivateKey = {},\r\n\r\n\t/**\r\n\t * Access the internal data, if this is an allowed thing to do.\r\n\t */\r\n\tgetData = function(region) {\r\n\t\treturn region._opaque(privateKey);\r\n\t},\r\n\r\n\t/**\r\n\t * Construct a 1-D region from the given array of start/end X coordinates.  This is a\r\n\t * proper object, with prototype methods for performing operations like\r\n\t * union/intersect/subtract/xor.\r\n\t *\r\n\t * Usage:  new Region1D(array)\r\n\t *\r\n\t * @param array {Array} - The array of span endpoints, in pairs of start (inclusive)\r\n\t *        and end (exclusive) X-coordinates.\r\n\t */\r\n\tRegion1D = function(array, key, hash) {\r\n\t\r\n\t\t// Internal-only second parameter: A 'key' flag, indicating this data came from an\r\n\t\t// internal operation and does not require validation for correctness.\r\n\t\tif (key === privateKey) {\r\n\t\t\r\n\t\t\t// Internal-only third parameter: A hash for comparisons.\r\n\t\t\tif (typeof hash !== 'number')\r\n\t\t\t\thash = makeHashCode(array);\r\n\t\t}\r\n\t\telse if (typeof key !== 'undefined' || typeof hash !== 'undefined') {\r\n\t\t\t// You're not allowed to specify a key unless it's the right one.\r\n\t\t\tthrow \"Illegal access\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Verify that the user passed us data that makes sense.\r\n\t\t\tvalidateData(array);\r\n\t\t\thash = makeHashCode(array);\r\n\t\t}\r\n\r\n\t\tthis._opaque = makeProtectedData({\r\n\t\t\tarray: array,\r\n\t\t\tmin: array.length ? array[0] : pInf,\r\n\t\t\tmax: array.length ? array[array.length - 1] : nInf,\r\n\t\t\thash: hash\r\n\t\t}, privateKey);\r\n\t};\r\n\t\r\n\t/**\r\n\t * The row's prototype contains helpers that simply invoke the private operations\r\n\t * to do all the hard work.\r\n\t */\r\n\tRegion1D.prototype = {\r\n\t\tunion: function(other) {\r\n\t\t\tverifyRegion1DType(other);\r\n\t\t\tconst data = getData(this), otherData = getData(other);\r\n\t\t\treturn new Region1D(unionData(data.array, otherData.array), privateKey);\r\n\t\t},\r\n\t\tintersect: function(other) {\r\n\t\t\tverifyRegion1DType(other);\r\n\t\t\tconst data = getData(this), otherData = getData(other);\r\n\t\t\treturn new Region1D(intersectData(data.array, otherData.array), privateKey);\r\n\t\t},\r\n\t\tsubtract: function(other) {\r\n\t\t\tverifyRegion1DType(other);\r\n\t\t\tconst data = getData(this), otherData = getData(other);\r\n\t\t\treturn new Region1D(subtractData(data.array, otherData.array), privateKey);\r\n\t\t},\r\n\t\txor: function(other) {\r\n\t\t\tverifyRegion1DType(other);\r\n\t\t\tconst data = getData(this), otherData = getData(other);\r\n\t\t\treturn new Region1D(xorData(data.array, otherData.array), privateKey);\r\n\t\t},\r\n\t\tnot: function() {\r\n\t\t\tconst data = getData(this);\r\n\t\t\treturn new Region1D(notData(data.array), privateKey);\r\n\t\t},\r\n\t\tisEmpty: function() {\r\n\t\t\treturn !getData(this).array.length;\r\n\t\t},\r\n\t\tgetCount: function() {\r\n\t\t\treturn getData(this).array.length >> 1;\r\n\t\t},\r\n\t\tdoesIntersect: function(other) {\r\n\t\t\tverifyRegion1DType(other);\r\n\t\t\treturn doesIntersectData(getData(this).array, getData(other).array);\r\n\t\t},\r\n\t\tisPointIn: function(x) {\r\n\t\t\treturn isPointInData(getData(this).array, Number(x));\r\n\t\t},\r\n\t\tequals: function(other) {\r\n\t\t\tverifyRegion1DType(other);\r\n\t\t\tconst data = getData(this), otherData = getData(other);\r\n\t\t\tif (data.hash != otherData.hash) return false;\r\n\t\t\treturn arrayEquals(data.array, otherData.array);\r\n\t\t},\r\n\t\tgetRawSpans: function() {\r\n\t\t\tconst data = getData(this);\r\n\t\t\treturn makeRawSpans(data.array);\r\n\t\t},\r\n\t\tgetAsRects: function(minY, maxY, destArray) {\r\n\t\t\tconst data = getData(this);\r\n\t\t\treturn makeRects(data.array, minY, maxY, destArray || []);\r\n\t\t},\r\n\t\tgetBounds: function() {\r\n\t\t\tconst data = getData(this);\r\n\t\t\treturn { min: data.min, max: data.max };\r\n\t\t},\r\n\t\tgetHashCode: function() {\r\n\t\t\treturn getData(this).hash;\r\n\t\t}\r\n\t};\r\n\r\n\t// Construct a convenient shareable 'empty' instance.\r\n\tRegion1D.empty = new Region1D([], privateKey, 0);\r\n\t\t\r\n\treturn Region1D;\r\n\r\n})();\r\n\r\nexport default Region1D;\r\n"]}