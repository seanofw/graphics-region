{"version":3,"file":"region1d.js","sources":["../../src/region1d.js"],"names":["Region1D","pInf","Number","POSITIVE_INFINITY","nInf","NEGATIVE_INFINITY","makeProtectedData","protectedData","expectedKey","actualKey","isArray","o","Array","combineData","array1","array2","op","length","i1","i2","getNext","x","kind","src","depth1","depth2","state","lastState","coord","result","nextCoord","push","unionData","intersectData","xorData","subtractData","doesIntersectData","lastDepth1","lastDepth2","isPointInData","array","i","l","notData","newArray","doesDataMatch","makeRects","y","height","min","max","width","makeChecksum","checksum","verifyRegion1DType","obj","console","error","validateData","typeError","typeErrorMsg","dataError","dataErrorMsg","prev","cur","privateKey","key","_opaque","minX","maxX","getData","region","prototype","clone","data","union","other","otherData","intersect","subtract","xor","not","isEmpty","doesIntersect","isPointIn","matches","getRects","getBounds","exports","this"],"mappings":"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","sourcesContent":["/**\r\n * Region1D objects are semi-opaque data structures that represent a 1-dimensional\r\n * region on the number line, described using \"spans\" of included points.\r\n *\r\n * ------------------------------------------------------------------------------------------------\r\n *\r\n * Each span in the region has an inclusive start and an exclusive end.  Spans may\r\n * not overlap, and always must appear in sorted order.  So, for example, consider\r\n * this set:\r\n *\r\n *           #####  ####      ###########       ####     #\r\n *        |----+----|----+----|----+----|----+----|----+----|\r\n *       0     5   10   15   20   25   30   35   40   45   50\r\n *\r\n * This set (inclusively) contains the numbers 3-7, 10-13, 20-30, 38-41, and 47.\r\n * Its Region1D representation (using only integer values) would therefore\r\n * consist of these ranges:\r\n *\r\n *   [3,8); [10,14); [20,31); [38,42); [47,48)\r\n *\r\n * And thus the resulting data array stored by the Region1D object would be:\r\n *\r\n *   [3, 8, 10, 14, 20, 31, 38, 42, 47, 48]\r\n *\r\n * Note that when you construct a Region1D, you *must* provide the data array\r\n * in sorted order, or the Region1D's constraints will be violated.\r\n *\r\n * ------------------------------------------------------------------------------------------------\r\n *\r\n * Region1Ds provide many operations that can be used to manipulate their\r\n * data as formal sets, including:\r\n *\r\n *   result = a.union(b);           // Return a new set that is the logical union of the two sets.\r\n *   result = a.intersect(b);       // Return a new set that is the logical intersection of the two sets.\r\n *   result = a.subtract(b);        // Return the logical subtraction of the two sets, i.e., the\r\n *                                  //   equivalent of a.union(b.not()), but computed more efficiently.\r\n *   result = a.xor(b);             // Return the exclusive-or of the two sets, i.e., those ranges\r\n *                                  //   which exist in one set or the other but not both.\r\n *   result = a.not();              // Return the logical complement of the set (which may include infinity).\r\n *   result = a.isEmpty();          // Return true/false if the set is empty.\r\n *   result = a.isPointIn(x);       // Return true if the given coordinate is contained within the set.\r\n *   result = a.doesIntersect(b);   // Return true if the logical intersection of the two sets is nonempty.\r\n *   result = a.matches(b);         // Return true if the sets are identical (ignoring their Y-coordinates).\r\n *   result = a.getBounds(b);       // Return { minX:, maxX: } of the Region1D.\r\n *   result = a.getRects(y, height); // Return an array of { x:, y:, width:, height: } rectangles describing the Region1D.\r\n *\r\n * All Region1D operations are carefully written to be bounded in both time and\r\n * space, and all will run in no worse than O(n) or O(n+m) time.\r\n */\r\nconst Region1D = (function() {\r\n\t\r\n\tconst\r\n\r\n\t//---------------------------------------------------------------------------------------------\r\n\t// Global constants.\r\n\t\r\n\t// Precache positive/negative infinity locally.\r\n\tpInf = Number.POSITIVE_INFINITY,\r\n\tnInf = Number.NEGATIVE_INFINITY,\r\n\r\n\t//---------------------------------------------------------------------------------------------\r\n\t// Helper functions.\r\n\r\n\t/**\r\n\t * Construct a wrapper around the given private data that makes it opaque except for \r\n\t * those with access to the 'expectedKey'.\r\n\t */\r\n\tmakeProtectedData = function(protectedData, expectedKey) {\r\n\t\treturn function(actualKey) {\r\n\t\t\tif (actualKey === expectedKey) return protectedData;\r\n\t\t\telse throw \"Illegal access\";\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Determine if the given object is an array. This is provided in newer JavaScript environs,\r\n\t * but is notably lacking in older ones.  We avoid a dependency on a huge package like CoreJS\r\n\t * by just defining the shim here.\r\n\t */\r\n\tisArray = function(o) {\r\n\t\treturn Array.isArray ? Array.isArray(o) : o instanceof Array;\r\n\t},\r\n\t\r\n\t//---------------------------------------------------------------------------------------------\r\n\t// 1-D raw-data-manipulation functions.\r\n\r\n\t/**\r\n\t * Calculate the combination of the given (sorted!) arrays of 1-D region data.\r\n\t * Returns a new array that contains the 1-D combination.\r\n\t */\r\n\tcombineData = function(array1, array2, op) {\r\n\r\n\t\t// Special case: Nothin' from nothin' gives nothin'.\r\n\t\tif (!array1.length && !array2.length)\r\n\t\t\treturn [];\r\n\r\n\t\tlet i1 = 0, i2 = 0;\r\n\t\t\r\n\t\t// Get the next coordinate with the lowest value from either array, keeping\r\n\t\t// track of whether it is a begin (+1) or end (-1) coordinate of its span.  O(1).\r\n\t\tconst getNext = function() {\r\n\t\t\tif (i1 >= array1.length && i2 >= array2.length)\r\n\t\t\t\treturn null;\r\n\t\t\telse if (i1 >= array1.length)\r\n\t\t\t\treturn { x: array2[i2], kind: i2++ & 1 ? -1 : +1, src: 2 };\r\n\t\t\telse if (i2 >= array2.length || array1[i1] < array2[i2])\r\n\t\t\t\treturn { x: array1[i1], kind: i1++ & 1 ? -1 : +1, src: 1 };\r\n\t\t\telse\r\n\t\t\t\treturn { x: array2[i2], kind: i2++ & 1 ? -1 : +1, src: 2 };\r\n\t\t};\r\n\t\t\r\n\t\tlet depth1 = 0, depth2 = 0;\r\n\t\tlet state = 0, lastState = 0;\r\n\r\n\t\t// Do whatever needs to happen at the very first coordinate.\r\n\t\tlet coord = getNext();\r\n\t\t\r\n\t\t// Process all of the coordinates until both arrays are empty, collecting\r\n\t\t// new spans in the 'result' array.  O(n+m).\r\n\t\tconst result = [];\r\n\t\tdo {\r\n\t\t\t// Do whatever happens at this first coordinate.\r\n\t\t\tif (coord.src === 1) depth1 += coord.kind;\r\n\t\t\telse depth2 += coord.kind;\r\n\r\n\t\t\t// Process any subsequent coordinates at the same 'x' offset,\r\n\t\t\t// also collecting the one after it.\r\n\t\t\tlet nextCoord;\r\n\t\t\twhile ((nextCoord = getNext()) && nextCoord.x === coord.x) {\r\n\t\t\t\tif (nextCoord.src === 1) depth1 += nextCoord.kind;\r\n\t\t\t\telse depth2 += nextCoord.kind;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Change the state to match whatever happened here.\r\n\t\t\tlastState = state;\r\n\t\t\tstate = op(depth1, depth2);\r\n\r\n\t\t\t// If we entered/exited a new span, emit a start/end X value.\r\n\t\t\tif (state !== lastState) {\r\n\t\t\t\tresult.push(coord.x);\r\n\t\t\t}\r\n\r\n\t\t\tcoord = nextCoord;\r\n\t\t} while (coord);\r\n\r\n\t\treturn result;\r\n\t},\r\n\r\n\t/**\r\n\t * Calculate the union of the given arrays of 1-D region data.\r\n\t * Returns a new array that contains the 1-D union.\r\n\t */\r\n\tunionData = (array1, array2) => combineData(array1, array2,\r\n\t\t(depth1, depth2) => (depth1 | depth2)\r\n\t),\r\n\r\n\t/**\r\n\t * Calculate the intersection of the given arrays of 1-D region data.\r\n\t * Returns a new array that contains the 1-D intersection.\r\n\t */\r\n\tintersectData = (array1, array2) => combineData(array1, array2,\r\n\t\t(depth1, depth2) => (depth1 & depth2)\r\n\t),\r\n\r\n\t/**\r\n\t * Calculate the exclusive-or of the given arrays of 1-D region data.\r\n\t * Returns a new array that contains the 1-D exclusive-or.\r\n\t */\r\n\txorData = (array1, array2) => combineData(array1, array2,\r\n\t\t(depth1, depth2) => (depth1 ^ depth2)\r\n\t),\r\n\r\n\t/**\r\n\t * Calculate the difference of the given arrays of 1-D region data.\r\n\t * Returns a new array that contains the 1-D difference.\r\n\t */\r\n\tsubtractData = (array1, array2) => combineData(array1, array2,\r\n\t\t(depth1, depth2) => (depth1 & ~depth2)\r\n\t),\r\n\r\n\t/**\r\n\t * Calculate whether the given arrays of 1-D region data intersect.\r\n\t * Returns true or false.\r\n\t */\r\n\tdoesIntersectData = function(array1, array2) {\r\n\t\t\r\n\t\t// If either is empty, there's no intersection.\r\n\t\tif (!array1.length || !array2.length) return false;\r\n\t\t\r\n\t\t// If all of the spans of one are before all of the spans of another, there's no intersection.\r\n\t\tif (array1[array1.length - 1] < array2[0]\r\n\t\t\t|| array2[array2.length - 1] < array1[0]) return false;\r\n\t\t\t\r\n\t\t// Test all the spans against each other.\r\n\t\tlet result = false;\r\n\t\tcombineData(array1, array2, (depth1, lastDepth1, depth2, lastDepth2) => {\r\n\t\t\tif ((depth1 | depth2) !== (lastDepth1 | lastDepth2))\r\n\t\t\t\tresult = true;\r\n\t\t\treturn false;\r\n\t\t});\r\n\t\treturn result;\r\n\t},\r\n\r\n\t/**\r\n\t * Determine whether the given point lies within the spans of the Region1D data.\r\n\t */\r\n\tisPointInData = function(array, x) {\r\n\t\t// It can't be in the empty set.\r\n\t\tif (!array.length) return false;\r\n\t\t\r\n\t\t// If it's outside the bounds, it's not anywhere within any of the spans.\r\n\t\tif (x < array[0] || x > array[array.length - 1]) return false;\r\n\t\t\r\n\t\t// Spin over all the spans for real.\r\n\t\tfor (let i = 0, l = array.length; i < l; i += 2) {\r\n\t\t\tif (x >= array[i] && x < array[i+1]) return true;\r\n\t\t}\r\n\t\t\r\n\t\treturn false;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Calculate a complement of the 1-D (sorted!) region data.\r\n\t * This is easy:\r\n\t *    If it starts with -Inf, remove that; otherwise, prepend -Inf.\r\n\t *    If it ends with +Inf, remove that; otherwise, append +Inf.\r\n\t * Returns a new array that contains the 1D complement.\r\n\t */\r\n\tnotData = function(array) {\r\n\t\tconst newArray = [];\r\n\r\n\t\tlet src = 0;\r\n\r\n\t\tif (!array.length) {\r\n\t\t\tnewArray.push(nInf);\r\n\t\t\tnewArray.push(pInf);\r\n\t\t\treturn newArray;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (array[src] != nInf) newArray.push(nInf);\r\n\t\t\telse src++;\r\n\t\t}\r\n\r\n\t\twhile (src < array.length - 1) {\r\n\t\t\tnewArray.push(array[src++]);\r\n\t\t}\r\n\r\n\t\tif (array[src] != pInf) {\r\n\t\t\tnewArray.push(array[src++]);\r\n\t\t\tnewArray.push(pInf);\r\n\t\t}\r\n\t\t\r\n\t\treturn newArray;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Determine if two arrays of (sorted!) 1-D region data are equivalent.\r\n\t * Returns true if they are the same, false if they are different.\r\n\t */\r\n\tdoesDataMatch = function(array1, array2) {\r\n\t\tif (array1.length != array2.length) return false;\r\n\t\tfor (let i = 0, l = array1.length; i < l; i++) {\r\n\t\t\tif (array1[i] != array2[i]) return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t},\r\n\r\n\t/**\r\n\t * Transform a set of 1-D region data into an array of rectangles with\r\n\t * the given same y and height values.\r\n\t *\r\n\t * Returns a new array that contains rectangles of the form { x:, y:, width: height: }.\r\n\t */\r\n\tmakeRects = function(array, y, height) {\r\n\t\tconst result = [];\r\n\t\t\r\n\t\tfor (let i = 0, l = array.length; i < l; i += 2) {\r\n\t\t\tconst min = array[i  ];\r\n\t\t\tconst max = array[i+1];\r\n\t\t\tresult.push({ x: min, y: y, width: max - min, height: height });\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t},\r\n\r\n\t/**\r\n\t * Calculate a checksum that (loosely) describes the given Region1D of data, so that we\r\n\t * can readily tell whether it is different from another.\r\n\t */\r\n\tmakeChecksum = function(array) {\r\n\t\tlet checksum = 0;\r\n\t\tfor (let i = 0, l = array.length; i < l; i++) {\r\n\t\t\tchecksum *= 23;\r\n\t\t\tchecksum += array[i] | 0;\r\n\t\t\tchecksum &= ~0;\r\n\t\t}\r\n\t\treturn checksum;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Check to ensure that the given object is actually a Region1D, and abort if it is not.\r\n\t */\r\n\tverifyRegion1DType = function(obj) {\r\n\t\tif (!(obj instanceof Region1D)) {\r\n\t\t\tconsole.error(\"Object must be a Region1D instance.\");\r\n\t\t\tthrow \"Type error\";\r\n\t\t}\r\n\t},\r\n\t\r\n\t/**\r\n\t * Check the given data to make sure that it consists of an array of ordered pairs\r\n\t * of span start/end points.\r\n\t */\r\n\tvalidateData = function(array) {\r\n\t\r\n\t\tconst typeError = \"Type error\";\r\n\t\tconst typeErrorMsg = \"Expected an ordered array of numeric start/end pairs.\";\r\n\t\tconst dataError = \"Data error\";\r\n\t\tconst dataErrorMsg = \"Array start/end pairs are not in strictly ascending order.\";\r\n\r\n\t\t// Make sure it's an array of even length.\r\n\t\tif (!isArray(array) || (array.length & 1)) {\r\n\t\t\tconsole.error(typeErrorMsg);\r\n\t\t\tthrow typeError;\r\n\t\t}\r\n\r\n\t\t// Empty array is always valid.\r\n\t\tif (array.length == 0) return;\r\n\r\n\t\t// Get the first entry, and make sure it's a number.\r\n\t\tlet prev = array[0];\r\n\t\tif (typeof prev !== 'number') {\r\n\t\t\tconsole.error(typeErrorMsg);\r\n\t\t\tthrow typeError;\r\n\t\t}\r\n\r\n\t\t// Check each successive entry to make sure that it's (A) a number and (B) strictly\r\n\t\t// greater than the entry before it.\r\n\t\tfor (let i = 1, l = array.length; i < l; i++) {\r\n\t\t\tlet cur = array[i];\r\n\t\t\tif (typeof cur !== 'number') {\r\n\t\t\t\tconsole.error(typeErrorMsg);\r\n\t\t\t\tthrow typeError;\r\n\t\t\t}\r\n\t\t\tif (cur <= prev) {\r\n\t\t\t\tconsole.error(dataErrorMsg);\r\n\t\t\t\tthrow dataError;\r\n\t\t\t}\r\n\t\t\tprev = cur;\r\n\t\t}\r\n\t},\r\n\t\r\n\t//---------------------------------------------------------------------------------------------\r\n\t// Public interface.\r\n\t\r\n\t/**\r\n\t * A special private object used to flag internal constructions in such a way that\r\n\t * external callers' data must be validated, but internal data can skip those checks.\r\n\t */\r\n\tprivateKey = {},\r\n\r\n\t/**\r\n\t * Construct a 1-D region from the given array of start/end X coordinates.  This is a\r\n\t * proper object, with prototype methods for performing operations like\r\n\t * union/intersect/subtract/xor.\r\n\t *\r\n\t * Usage:  new Region1D(array)\r\n\t *\r\n\t * @param array {Array} - The array of span endpoints, in pairs of start (inclusive)\r\n\t *        and end (exclusive) X-coordinates.\r\n\t */\r\n\tRegion1D = function(array, key, checksum) {\r\n\t\r\n\t\t// Internal-only second parameter: A 'key' flag, indicating this data came from an\r\n\t\t// internal operation and does not require validation for correctness.\r\n\t\tif (key === privateKey) {\r\n\t\t\r\n\t\t\t// Internal-only third parameter: A checksum for comparisons.\r\n\t\t\tif (typeof checksum !== 'number')\r\n\t\t\t\tchecksum = makeChecksum(array);\r\n\t\t}\r\n\t\telse if (typeof key !== 'undefined' || typeof checksum !== 'undefined') {\r\n\t\t\t// You're not allowed to specify a key unless it's the right one.\r\n\t\t\tthrow \"Illegal access\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Verify that the user passed us data that makes sense.\r\n\t\t\tvalidateData(array);\r\n\t\t\tchecksum = makeChecksum(array);\r\n\t\t}\r\n\r\n\t\tthis._opaque = makeProtectedData({\r\n\t\t\tarray: array,\r\n\t\t\tminX: array.length ? array[0] : pInf,\r\n\t\t\tmaxX: array.length ? array[array.length - 1] : nInf,\r\n\t\t\tchecksum: checksum\r\n\t\t}, privateKey);\r\n\t};\r\n\r\n\t/**\r\n\t * Access the internal data, if this is an allowed thing to do.\r\n\t */\r\n\tconst getData = function(region) {\r\n\t\treturn region._opaque(privateKey);\r\n\t};\r\n\t\r\n\t/**\r\n\t * The row's prototype contains helpers that simply invoke the private operations\r\n\t * to do all the hard work.\r\n\t */\r\n\tRegion1D.prototype = {\r\n\t\tclone: function() {\r\n\t\t\tconst data = getData(this);\r\n\t\t\treturn new Region1D(data.array, privateKey, data.checksum);\r\n\t\t},\r\n\t\tunion: function(other) {\r\n\t\t\tverifyRegion1DType(other);\r\n\t\t\tconst data = getData(this), otherData = getData(other);\r\n\t\t\treturn new Region1D(unionData(data.array, otherData.array), privateKey);\r\n\t\t},\r\n\t\tintersect: function(other) {\r\n\t\t\tverifyRegion1DType(other);\r\n\t\t\tconst data = getData(this), otherData = getData(other);\r\n\t\t\treturn new Region1D(intersectData(data.array, otherData.array), privateKey);\r\n\t\t},\r\n\t\tsubtract: function(other) {\r\n\t\t\tverifyRegion1DType(other);\r\n\t\t\tconst data = getData(this), otherData = getData(other);\r\n\t\t\treturn new Region1D(subtractData(data.array, otherData.array), privateKey);\r\n\t\t},\r\n\t\txor: function(other) {\r\n\t\t\tverifyRegion1DType(other);\r\n\t\t\tconst data = getData(this), otherData = getData(other);\r\n\t\t\treturn new Region1D(xorData(data.array, otherData.array), privateKey);\r\n\t\t},\r\n\t\tnot: function() {\r\n\t\t\tconst data = getData(this);\r\n\t\t\treturn new Region1D(notData(data.array), privateKey);\r\n\t\t},\r\n\t\tisEmpty: function() {\r\n\t\t\treturn !!getData(this).array.length;\r\n\t\t},\r\n\t\tdoesIntersect: function(other) {\r\n\t\t\tverifyRegion1DType(other);\r\n\t\t\treturn doesIntersectData(getData(this).array, getData(other).array);\r\n\t\t},\r\n\t\tisPointIn: function(x) {\r\n\t\t\treturn isPointInData(getData(this).array, Number(x));\r\n\t\t},\r\n\t\tmatches: function(other) {\r\n\t\t\tverifyRegion1DType(other);\r\n\t\t\tconst data = getData(this), otherData = getData(other);\r\n\t\t\tif (data.checksum != otherData.checksum) return false;\r\n\t\t\treturn doesDataMatch(data.array, otherData.array);\r\n\t\t},\r\n\t\tgetRects: function(y, height) {\r\n\t\t\tconst data = getData(this);\r\n\t\t\treturn makeRects(data.array, y, height);\r\n\t\t},\r\n\t\tgetBounds: function() {\r\n\t\t\tconst data = getData(this);\r\n\t\t\treturn { minX: data.minX, maxX: data.maxX };\r\n\t\t}\r\n\t};\r\n\t\t\r\n\treturn Region1D;\r\n\r\n})();\r\n\r\n// Export it for use in Node-type environments.\r\nif (typeof exports !== 'undefined') {\r\n\texports.Region1D = Region1D;\r\n}\r\n"]}