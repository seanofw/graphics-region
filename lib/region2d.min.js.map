{"version":3,"file":"region2d.js","sources":["../src/region2d.js"],"names":["Region2D","infinite","empty","pInf","Number","POSITIVE_INFINITY","nInf","NEGATIVE_INFINITY","regionError","makeProtectedData","protectedData","expectedKey","actualKey","isArray","o","Array","makeRowPairGenerator","rows1","rows2","rowIndex1","rowIndex2","lastY","length","result","row1","row2","region","minY","Math","max","maxY","nextY1","nextY2","da","db","combineData","array1","array2","rowTransform","pairGenerator","lastResult","minX","maxX","hash","count","pair","resultRow","isEmpty","equals","push","getCount","rowBounds","getBounds","min","getHashCode","newRegionData","array","unionData","r1","r2","union","intersectData","intersect","xorData","xor","subtractData","subtract","generateEdges","edges","spans","getRawSpans","y1","y2","i","x1","x2","kind","key1","key2","next","prev","used","rowIndex","numRows","interiorEdges","makeEdgeTable","table","l","edge","makeWindings","allWindings","firstEdge","lastEdge","consumeEdge","findBestPossibleEdge","possibleEdges","winding","startEdge","x","y","currentEdge","prevX","prevPrevX","pop","makePath","windings","transformData","ratioX","ratioY","deltaX","deltaY","newArray","row","transform","doBoundsOverlap","data1","data2","cannotConstructMessage","invalidRectangleDataMessage","invalidRectangleSizeMessage","makeRegionDataFromOneRect","rect","HTMLElement","clientRect","getBoundingClientRect","window","scrollX","left","scrollY","top","right","bottom","width","height","region1D","data","makeEmptyRegionData","rowDataErrorMessage","makeDataFromRows","bands","prevMax","band","rowCount","bounds","getBoundsFromData","getRawRows","srcArray","destArray","src","makeRects","getAsRects","isInfinite","arrayEquals","doesIntersectData","isPointInData","isPointIn","start","end","midpt","verifyRegion2DType","obj","privateKey","getData","_opaque","key","prototype","other","otherData","not","scaleX","scaleY","offsetX","offsetY","translate","scale","isFinite","isRectangular","doesIntersect","getRects","getPath","fromRects","rects","fromRawRows","rows","Region1D","RegionError","_region1d","require","this"],"mappings":"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","sourcesContent":["import { Region1D, RegionError } from './region1d';\r\n\r\n/**\r\n * Region2D objects are semi-opaque data structures that represent a 2-dimensional\r\n * set in the plane, described using axis-aligned rectangles of included points.\r\n * \r\n * ------------------------------------------------------------------------------------------------\r\n * \r\n * Region2D objects are capable of performing most major set-theoretic operations, including:\r\n * \r\n *   result = a.union(b);           // Return a new set that is the logical union of the two sets.\r\n *   result = a.intersect(b);       // Return a new set that is the logical intersection of the two sets.\r\n *   result = a.subtract(b);        // Return the logical subtraction of the two sets, i.e., the\r\n *                                  //   equivalent of a.union(b.not()), but computed more efficiently.\r\n *   result = a.xor(b);             // Return the exclusive-or of the two sets, i.e., those ranges\r\n *                                  //   which exist in one set or the other but not both.\r\n *   result = a.not();              // Return the logical complement of the set (which may include infinity).\r\n *   result = a.isEmpty();          // Return true/false if the set is empty.\r\n *   result = a.isFinite();         // Return true/false if the set is finite (doesn't stretch to infinity).\r\n *   result = a.isInfinite();       // Return true/false if the set stretches to infinity in any direction.\r\n *   result = a.isRectangular();    // Return true/false if the set can be described by a single rectangle.\r\n *   result = a.isPointIn(x, y);    // Return true if the given point is contained within the set.\r\n *   result = a.doesIntersect(b);   // Return true if the logical intersection of the two sets is nonempty.  This is\r\n *                                  //   more efficient than performing \"!a.intersect(b).isEmpty()\".\r\n *   result = a.equals(b);          // Return true if the sets are identical.\r\n *   result = a.getCount();         // Return the number of nonoverlapping rectangles that would describe this Region2D.\r\n *   result = a.getRects();\t\t\t// Return an array of nonoverlapping rectangles describing the Region2D.\r\n *   result = a.getBounds(b);       // Return a boundary rectangle containing all of the points of the Region2D.\r\n *\r\n * All Region2D operations are carefully written to be bounded in both time and\r\n * space, and all will run in no worse than O(n) or O(n+m) time.\r\n *\r\n * ------------------------------------------------------------------------------------------------\r\n * \r\n * Under the hood, this is partially implemented using Region1D.  Each Region2D consists of an\r\n * array of Region1D \"rows\" or \"bands,\" which represent sets of rectangles with identical\r\n * minY/maxY coordinates.  Each of the rows must be nonempty and must be unique (i.e., a successive\r\n * row's spans must not equal a previous row spans, if the maxY of the previous row equals the minY\r\n * of the successive row).\r\n * \r\n * Representing regions like this is how X Windows does it, and while this design may not always\r\n * result in the most optimized set of rectangles, the operations to work with these kinds of\r\n * regions are provably efficient:  This design trades space for time.\r\n * \r\n * As a rather nice side-effect of the design, calls to getRects() will always result in a set\r\n * of rectangles that go from top-to-bottom, left-to-right on the screen, which can be beneficial\r\n * in some rendering scenarios.\r\n * \r\n * This implementation also has performance optimizations to avoid combining regions when the\r\n * operations are meaningless or would result in the empty set, and there are various kinds of\r\n * boundary checks to early-out operations wherever possible.\r\n */\r\nconst Region2D = (function() {\r\n\r\n\tlet infinite, empty;\r\n\r\n\tconst\r\n\r\n\t//---------------------------------------------------------------------------------------------\r\n\t// Global constants.\r\n\t\r\n\t// Precache positive/negative infinity locally.\r\n\tpInf = Number.POSITIVE_INFINITY,\r\n\tnInf = Number.NEGATIVE_INFINITY,\r\n\r\n\tregionError = RegionError,\r\n\r\n\t//---------------------------------------------------------------------------------------------\r\n\t// Helper functions.\r\n\r\n\t/**\r\n\t * Construct a wrapper around the given private data that makes it opaque except for \r\n\t * those with access to the 'expectedKey'.\r\n\t */\r\n\tmakeProtectedData = function(protectedData, expectedKey) {\r\n\t\treturn function(actualKey) {\r\n\t\t\tif (actualKey === expectedKey) return protectedData;\r\n\t\t\telse throw new regionError(\"Illegal access\");\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Determine if the given object is an array. This is provided in newer JavaScript environs,\r\n\t * but is notably lacking in older ones.  We avoid a dependency on a huge package like CoreJS\r\n\t * by just defining the shim here.\r\n\t */\r\n\tisArray = function(o) {\r\n\t\treturn Array.isArray ? Array.isArray(o) : o instanceof Array;\r\n\t},\r\n\r\n\t//---------------------------------------------------------------------------------------------\r\n\t// Region core internals.\r\n\r\n\t/**\r\n\t * Make a 'generator' function that, upon each invocation, will return the next\r\n\t * pair of rows that need to be combined, as the form { row1:, row2:, minY:, maxY: },\r\n\t * where row1 and row2 are the original Region1D objects, and minY and maxY should\r\n\t * be the Y coordinates of the resulting combined row.  This is actually a lot simpler\r\n\t * than it looks, but many separate cases need to be handled.\r\n\t * \r\n\t * On each separate invocation, the generator will return a new pair object until it\r\n\t * runs out of source rows, and then it will return null.\r\n\t */\r\n\tmakeRowPairGenerator = function(rows1, rows2) {\r\n\t\tlet rowIndex1 = 0;\r\n\t\tlet rowIndex2 = 0;\r\n\t\tlet lastY = nInf;\r\n\t\tlet empty = Region1D.empty;\r\n\r\n\t\treturn function() {\r\n\r\n\t\t\t//-------------------------------------------------------------------------------------\r\n\t\t\t// Step 1.  First, see if we've run out of data in either set.\r\n\r\n\t\t\tif (rowIndex1 >= rows1.length) {\r\n\t\t\t\t// No more left in rows1, so just take whatever's left of rows2.\r\n\t\t\t\tif (rowIndex2 >= rows2.length)\r\n\t\t\t\t\treturn null;\r\n\t\t\t\telse {\r\n\t\t\t\t\tconst result = {\r\n\t\t\t\t\t\trow1: empty, row2: rows2[rowIndex2].region,\r\n\t\t\t\t\t\tminY: Math.max(rows2[rowIndex2].minY, lastY), maxY: (lastY = rows2[rowIndex2].maxY)\r\n\t\t\t\t\t};\r\n\t\t\t\t\trowIndex2++;\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (rowIndex2 >= rows2.length) {\r\n\t\t\t\t// No more left in rows2, so just take whatever's left of rows1.\r\n\t\t\t\tconst result = {\r\n\t\t\t\t\trow1: rows1[rowIndex1].region, row2: empty,\r\n\t\t\t\t\tminY: Math.max(rows1[rowIndex1].minY, lastY), maxY: (lastY = rows1[rowIndex1].maxY)\r\n\t\t\t\t};\r\n\t\t\t\trowIndex1++;\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// We have remaining rows in both rows1 and rows2, so now we need\r\n\t\t\t\t// to do the general case.\r\n\t\t\t}\r\n\r\n\t\t\t//-------------------------------------------------------------------------------------\r\n\t\t\t// Step 2. Extract out the next row pair.  This is a somewhat-straightforward\r\n\t\t\t//   decision-tree approach, and is very fast, but since there are many possible\r\n\t\t\t//   cases, there are a lot of conditionals below to test for all of them.\r\n\r\n\t\t\tconst row1 = rows1[rowIndex1];\r\n\t\t\tconst row2 = rows2[rowIndex2];\r\n\t\t\tconst nextY1 = Math.max(row1.minY, lastY);\r\n\t\t\tconst nextY2 = Math.max(row2.minY, lastY);\r\n\r\n\t\t\tlet da, db, minY, maxY;\r\n\r\n\t\t\tif (nextY1 === nextY2) {\r\n\t\t\t\t// The A-side and B-side rows having a matching top edge.\r\n\t\t\t\tminY = nextY1;\r\n\r\n\t\t\t\t// These match the first half of the conditionals described below.\r\n\t\t\t\tda = row1.region, db = row2.region;\r\n\t\t\t\tif (row2.maxY < row1.maxY) {\r\n\t\t\t\t\tlastY = maxY = row2.maxY;\r\n\t\t\t\t\trowIndex2++;\r\n\t\t\t\t}\r\n\t\t\t\telse if (row2.maxY === row1.maxY) {\r\n\t\t\t\t\tlastY = maxY = row1.maxY;\r\n\t\t\t\t\trowIndex1++, rowIndex2++;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tlastY = maxY = row1.maxY;\r\n\t\t\t\t\trowIndex1++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (nextY1 < nextY2) {\r\n\t\t\t\t// The A-side row is strictly above the B-side row.\r\n\t\t\t\tminY = nextY1;\r\n\r\n\t\t\t\t// These match the second half of the conditionals described below.\r\n\t\t\t\tda = row1.region, db = empty;\r\n\t\t\t\tif (nextY2 >= row1.maxY) {\r\n\t\t\t\t\tlastY = maxY = row1.maxY;\r\n\t\t\t\t\trowIndex1++;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tlastY = maxY = nextY2;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// The B-side row is strictly above the A-side row.\r\n\t\t\t\tminY = nextY2;\r\n\r\n\t\t\t\t// These match the second half of the conditionals described below, inverted.\r\n\t\t\t\tda = empty, db = row2.region;\r\n\t\t\t\tif (nextY1 >= row2.maxY) {\r\n\t\t\t\t\tlastY = maxY = row2.maxY;\r\n\t\t\t\t\trowIndex2++;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tlastY = maxY = nextY1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//-------------------------------------------------------------------------------------\r\n\t\t\t// Step 3. Emit the result for this row pair.\r\n\r\n\t\t\tconst result = {\r\n\t\t\t\trow1: da, row2: db,\r\n\t\t\t\tminY: minY, maxY: maxY\r\n\t\t\t};\r\n\t\t\treturn result;\r\n\r\n\t\t\t/*\r\n\t\t\t\t//-------------------------------------------------------------------------------------\r\n\t\t\t\t// Step 2, in detail.  Both sides follow the same basic algorithm, as\r\n\t\t\t\t// explained below:\r\n\t\t\t\t//\r\n\t\t\t\t// Find the maxY, and iterate whichever side is the next one that requires\r\n\t\t\t\t// iteration (possibly both).\r\n\r\n\t\t\t\tif (ay === by) {\r\n\t\t\t\t\t// Top edges are equal, so we're consuming part or all of both rows.\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// Case 1.  +-------+   +-------+   <--- top equal\r\n\t\t\t\t\t//          |   a   |   |   b   |\r\n\r\n\t\t\t\t\t// Three possibilities:  rb.maxY is above, equal to, or below ra.maxY.\r\n\t\t\t\t\tif (rb.maxY < ra.maxY) {\r\n\t\t\t\t\t\t// Case 1a.  +-------+   +-------+   <--- top equal\r\n\t\t\t\t\t\t//           |   a   |   |   b   |\r\n\t\t\t\t\t\t//           |       |   +-------+   <--- bottom above\r\n\t\t\t\t\t\t//           +-------+\r\n\t\t\t\t\t\t// Consume all of rb, but only the top part of ra.\r\n\t\t\t\t\t\tlastY = maxY = rb.maxY;\r\n\t\t\t\t\t\tda = ra.region;\r\n\t\t\t\t\t\tdb = rb.region;\r\n\t\t\t\t\t\tib++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (rb.maxY === ra.maxY) {\r\n\t\t\t\t\t\t// Case 1b.  +-------+   +-------+   <--- top equal\r\n\t\t\t\t\t\t//           |   a   |   |   b   |\r\n\t\t\t\t\t\t//           +-------+   +-------+   <--- bottom equal\r\n\t\t\t\t\t\t// Consume both ra and rb.\r\n\t\t\t\t\t\tlastY = maxY = ra.maxY;\r\n\t\t\t\t\t\tda = ra.region;\r\n\t\t\t\t\t\tdb = rb.region;\r\n\t\t\t\t\t\tia++;\r\n\t\t\t\t\t\tib++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t// Case 1c.  +-------+   +-------+   <--- top equal\r\n\t\t\t\t\t\t//           |   a   |   |   b   |\r\n\t\t\t\t\t\t//           +-------+   |       |\r\n\t\t\t\t\t\t//                       +-------+   <--- bottom below\r\n\t\t\t\t\t\t// Consume all of ra, but only the top part of rb.\r\n\t\t\t\t\t\tlastY = maxY = ra.maxY;\r\n\t\t\t\t\t\tda = ra.region;\r\n\t\t\t\t\t\tdb = rb.region;\r\n\t\t\t\t\t\tia++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (by >= ra.maxY) {\r\n\t\t\t\t\t// Degenerate case:  by is past ra.maxY, so there\r\n\t\t\t\t\t// is no overlap at all.\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// Case 2.  +-------+   \r\n\t\t\t\t\t//          |   a   |\r\n\t\t\t\t\t//          +-------+\r\n\t\t\t\t\t//                      +-------+   <--- top entirely below a\r\n\t\t\t\t\t//                      |   b   |\r\n\t\t\t\t\t//                      +-------+\r\n\t\t\t\t\t// Consume all of ra, and none of rb.\r\n\t\t\t\t\tlastY = maxY = ra.maxY;\r\n\t\t\t\t\tda = ra.region;\r\n\t\t\t\t\tdb = empty;\r\n\t\t\t\t\tia++;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// Top edge of rb is below the top edge of ra, but there's definitely\r\n\t\t\t\t\t// overlap.  So we now need to decide how much overlap.\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// Case 3.  +-------+   \r\n\t\t\t\t\t//          |   a   |   +-------+   <--- top below\r\n\t\t\t\t\t//          |       |   |   b   |\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// Consume the next part of ra through by, but none of rb.\r\n\t\t\t\t\tlastY = maxY = by;\r\n\t\t\t\t\tda = ra.region;\r\n\t\t\t\t\tdb = empty;\r\n\t\t\t\t}\r\n\t\t\t*/\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Combine two regions together, returning a new region that is the result of having\r\n\t * combined them, using the provided rowTransform to mutate their individual rows.\r\n\t *\r\n\t * This spins over the rows of the regions in parallel, \"peeling off\" each successive\r\n\t * unique pair of rows with identical Y coordinates, and then invokes the transform\r\n\t * to perform the actual combination.  The transformed row is then added to the pile\r\n\t * of output rows, with a few interesting caveats to maintain the region invariants:\r\n\t *\r\n\t *   - We don't add a row that is identical to the previous row; we expand the previous row.\r\n\t *   - We don't add empty rows at all.\r\n\t *   - We do track the boundary min/max X coordinates as we go.\r\n\t *   - We compute the overall region hash as we go.\r\n\t *   - We only compute the boundary min/max Y coordinates after all rows are added.\r\n\t *\r\n\t * Neither input region may be empty.\r\n\t *\r\n\t * The result is always a valid region if the two input regions are valid regions.\r\n\t */\r\n\tcombineData = function(array1, array2, rowTransform) {\r\n\r\n\t\t// Make the generator that spits out pairs of rows to combine.\r\n\t\tconst pairGenerator = makeRowPairGenerator(array1, array2);\r\n\r\n\t\t// Spin over all the pairs of input rows, and combine them together to produce\r\n\t\t// the output region.\r\n\t\tlet lastResult = null;\r\n\t\tconst result = [];\r\n\t\tlet minX = pInf, maxX = nInf;\r\n\t\tlet hash = 0;\r\n\t\tlet count = 0;\r\n\t\tfor (let pair; pair = pairGenerator(); ) {\r\n\r\n\t\t\t// Perform the 1-dimensional version of the transform.\r\n\t\t\tconst resultRow = rowTransform(pair.row1, pair.row2);\r\n\r\n\t\t\t// If the result is empty, we don't add it.\r\n\t\t\tif (resultRow.isEmpty())\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t// If the result is the same as the previous row's result, and they're immediately\r\n\t\t\t// adjacent, then just expand the previous row: Don't add a new one.\r\n\t\t\tif (lastResult && resultRow.equals(lastResult.region) && lastResult.maxY == pair.minY) {\r\n\t\t\t\tlastResult.maxY = pair.maxY;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// New result row, and it's valid content, so add it to the result.\r\n\t\t\tresult.push(lastResult = {\r\n\t\t\t\tregion: resultRow,\r\n\t\t\t\tminY: pair.minY,\r\n\t\t\t\tmaxY: pair.maxY,\r\n\t\t\t});\r\n\r\n\t\t\t// Update the rectangle count.\r\n\t\t\tcount += resultRow.getCount();\r\n\r\n\t\t\t// Update the minima and maxima for this 2-D region based on the new row.\r\n\t\t\tconst rowBounds = resultRow.getBounds();\r\n\t\t\tif (rowBounds.min < minX) minX = rowBounds.min;\r\n\t\t\tif (rowBounds.max > maxX) maxX = rowBounds.max;\r\n\r\n\t\t\t// Update the hash (checksum) for the 2-D region based on the 1-D row hash.\r\n\t\t\thash *= 23;\r\n\t\t\thash += resultRow.getHashCode() | 0;\r\n\t\t\thash &= ~0;\r\n\t\t}\r\n\r\n\t\t// Finally, generate the 2-D region data itself.\r\n\t\tconst newRegionData = {\r\n\t\t\tarray: result,\r\n\t\t\tcount: count,\r\n\t\t\tminX: minX,\r\n\t\t\tminY: result.length ? result[0].minY : pInf,\r\n\t\t\tmaxX: maxX,\r\n\t\t\tmaxY: result.length ? result[result.length-1].maxY : nInf,\r\n\t\t\thash: hash\r\n\t\t};\r\n\t\treturn newRegionData;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Calculate the union of the given arrays of 2-D region data.\r\n\t * Returns a new array that contains the 2-D union.\r\n\t */\r\n\tunionData = (array1, array2) => combineData(array1, array2, (r1, r2) => r1.union(r2)),\r\n\r\n\t/**\r\n\t * Calculate the intersection of the given arrays of 2-D region data.\r\n\t * Returns a new array that contains the 2-D intersection.\r\n\t */\r\n\tintersectData = (array1, array2) => combineData(array1, array2, (r1, r2) => r1.intersect(r2)),\r\n\r\n\t/**\r\n\t * Calculate the exclusive-or of the given arrays of 2-D region data.\r\n\t * Returns a new array that contains the 2-D exclusive-or.\r\n\t */\r\n\txorData = (array1, array2) => combineData(array1, array2, (r1, r2) => r1.xor(r2)),\r\n\r\n\t/**\r\n\t * Calculate the difference of the given arrays of 2-D region data.\r\n\t * Returns a new array that contains the 2-D difference.\r\n\t */\r\n\tsubtractData = (array1, array2) => combineData(array1, array2, (r1, r2) => r1.subtract(r2)),\r\n\r\n\t//---------------------------------------------------------------------------------------------\r\n\t// Support for generation of paths/windings.\r\n\r\n\t/**\r\n\t * Extract the edges of this region.  The edges are fairly-easily extracted from the row data:\r\n\t * All vertical lines in each row are valid edges, and horizontal lines are valid wherever\r\n\t * the XOR with the adjacent row is nonempty.\r\n\t */\r\n\tgenerateEdges = function(array) {\r\n\t\tconst edges = [];\r\n\r\n\t\tif (array.length < 1) {\r\n\t\t\treturn [];\r\n\t\t}\r\n\t\telse if (array.length === 1) {\r\n\t\t\t// Degenerate case: Only one row.\r\n\t\t\tconst spans = array[0].region.getRawSpans();\r\n\t\t\tconst y1 = array[0].minY;\r\n\t\t\tconst y2 = array[0].maxY;\r\n\t\t\tfor (let i = 0; i < spans.length; i += 2) {\r\n\t\t\t\tedges.push({ x1: spans[i], y1: y1, x2: spans[i+1], y2: y1, kind: \"top\",\r\n\t\t\t\t\tkey1: null, key2: null, next: null, prev: null, used: false });\r\n\t\t\t\tedges.push({ x1: spans[i+1], y1: y1, x2: spans[i+1], y2: y2, kind: \"right\",\r\n\t\t\t\t\tkey1: null, key2: null, next: null, prev: null, used: false });\r\n\t\t\t\tedges.push({ x1: spans[i+1], y1: y2, x2: spans[i], y2: y2, kind: \"bottom\",\r\n\t\t\t\t\tkey1: null, key2: null, next: null, prev: null, used: false });\r\n\t\t\t\tedges.push({ x1: spans[i], y1: y2, x2: spans[i], y2: y1, kind: \"left\",\r\n\t\t\t\t\tkey1: null, key2: null, next: null, prev: null, used: false });\r\n\t\t\t}\r\n\t\t\treturn edges;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Main case: N rows, N > 1\r\n\t\t\t\r\n\t\t\t// First, emit the top edge(s) and verticals.\r\n\t\t\tlet spans = array[0].region.getRawSpans();\r\n\t\t\tlet y1 = array[0].minY;\r\n\t\t\tlet y2 = array[0].maxY;\r\n\t\t\tfor (let i = 0; i < spans.length; i += 2) {\r\n\t\t\t\tedges.push({ x1: spans[i], y1: y1, x2: spans[i+1], y2: y1, kind: \"top\",\r\n\t\t\t\t\tkey1: null, key2: null, next: null, prev: null, used: false });\r\n\t\t\t\tedges.push({ x1: spans[i+1], y1: y1, x2: spans[i+1], y2: y2, kind: \"right\",\r\n\t\t\t\t\tkey1: null, key2: null, next: null, prev: null, used: false });\r\n\t\t\t\tedges.push({ x1: spans[i], y1: y2, x2: spans[i], y2: y1, kind: \"left\",\r\n\t\t\t\t\tkey1: null, key2: null, next: null, prev: null, used: false });\r\n\t\t\t}\r\n\r\n\t\t\t// Now handle the interior rows.\r\n\t\t\tfor (let rowIndex = 1, numRows = array.length; rowIndex < numRows; rowIndex++) {\r\n\r\n\t\t\t\ty1 = array[rowIndex].minY;\r\n\t\t\t\ty2 = array[rowIndex].maxY;\r\n\r\n\t\t\t\tif (y1 > array[rowIndex - 1].maxY) {\r\n\t\t\t\t\t// Emit bottom edges for the previous row verbatim, since it doesn't touch this row.\r\n\t\t\t\t\tfor (let i = 0; i < spans.length; i += 2) {\r\n\t\t\t\t\t\tedges.push({ x1: spans[i+1], y1: array[rowIndex-1].maxY, x2: spans[i], y2: array[rowIndex-1].maxY, kind: \"bottom\",\r\n\t\t\t\t\t\t\tkey1: null, key2: null, next: null, prev: null, used: false });\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Emit top edges for this row verbatim, since it doesn't touch the previous row.\r\n\t\t\t\t\tspans = array[rowIndex].region.getRawSpans();\r\n\t\t\t\t\tfor (let i = 0; i < spans.length; i += 2) {\r\n\t\t\t\t\t\tedges.push({ x1: spans[i], y1: y1, x2: spans[i+1], y2: y1, kind: \"top\",\r\n\t\t\t\t\t\t\tkey1: null, key2: null, next: null, prev: null, used: false });\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// Emit bottom edges for the previous row by subtracting away this row.\r\n\t\t\t\t\tlet interiorEdges = array[rowIndex-1].region.subtract(array[rowIndex].region);\r\n\t\t\t\t\tspans = interiorEdges.getRawSpans();\r\n\t\t\t\t\tfor (let i = 0; i < spans.length; i += 2) {\r\n\t\t\t\t\t\tedges.push({ x1: spans[i+1], y1: y1, x2: spans[i], y2: y1, kind: \"bottom\",\r\n\t\t\t\t\t\t\tkey1: null, key2: null, next: null, prev: null, used: false });\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Emit top edges for this row by subtracting away the previous row.\r\n\t\t\t\t\tinteriorEdges = array[rowIndex].region.subtract(array[rowIndex-1].region);\r\n\t\t\t\t\tspans = interiorEdges.getRawSpans();\r\n\t\t\t\t\tfor (let i = 0; i < spans.length; i += 2) {\r\n\t\t\t\t\t\tedges.push({ x1: spans[i], y1: y1, x2: spans[i+1], y2: y1, kind: \"top\",\r\n\t\t\t\t\t\t\tkey1: null, key2: null, next: null, prev: null, used: false });\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Emit verticals everywhere on this row.\r\n\t\t\t\tspans = array[rowIndex].region.getRawSpans();\r\n\t\t\t\tfor (let i = 0; i < spans.length; i += 2) {\r\n\t\t\t\t\tedges.push({ x1: spans[i+1], y1: y1, x2: spans[i+1], y2: y2, kind: \"right\",\r\n\t\t\t\t\t\tkey1: null, key2: null, next: null, prev: null, used: false });\r\n\t\t\t\t\tedges.push({ x1: spans[i], y1: y2, x2: spans[i], y2: y1, kind: \"left\",\r\n\t\t\t\t\t\tkey1: null, key2: null, next: null, prev: null, used: false });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Finally, emit the bottom edge(s) for the last row.\r\n\t\t\tfor (let i = 0; i < spans.length; i += 2) {\r\n\t\t\t\tedges.push({ x1: spans[i+1], y1: y2, x2: spans[i], y2: y2, kind: \"bottom\",\r\n\t\t\t\t\tkey1: null, key2: null, next: null, prev: null, used: false });\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn edges;\r\n\t},\r\n\r\n\t/**\r\n\t * Make a lookup table that finds edges quickly (O(1)) by either endpoint, and set up the\r\n\t * edges as a linked list so it's easy to quickly (O(1)) find any un-consumed edge.\r\n\t */\r\n\tmakeEdgeTable = function(edges) {\r\n\t\tconst table = {};\r\n\r\n\t\tfor (let i = 0, l = edges.length; i < l; i++) {\r\n\t\t\tconst edge = edges[i];\r\n\r\n\t\t\tedge.key1 = (edge.x1 + \",\" + edge.y1);\r\n\t\t\tedge.key2 = (edge.x2 + \",\" + edge.y2);\r\n\r\n\t\t\tedge.prev = i > 0 ? edges[i-1] : null;\r\n\t\t\tedge.next = i < l-1 ? edges[i+1] : null;\r\n\r\n\t\t\t// We only add the 'start' endpoint to the lookup table, because that's\r\n\t\t\t// the only point we want to follow to.\r\n\t\t\tif (!(edge.key1 in table)) table[edge.key1] = [edge];\r\n\t\t\telse table[edge.key1].push(edge);\r\n\t\t}\r\n\r\n\t\treturn table;\r\n\t},\r\n\r\n\t/**\r\n\t * Make the windings, clockwise polygons that are formed from adjacent edges.\r\n\t */\r\n\tmakeWindings = function(edges, table) {\r\n\t\t// Algorithm:\r\n\t\t//\r\n\t\t// Starting with a top edge, follow its endpoints clockwise until we reach that same\r\n\t\t// start edge.  Wherever duplicate points are found, prefer following top->right,\r\n\t\t// right->bottom, bottom->left, and left->top.  Remove each edge from the source set\r\n\t\t// as we follow it.  When we reach the start edge, if there are edges left, repeat the\r\n\t\t// same whole algorithm until no edges are left.\r\n\r\n\t\tconst allWindings = [];\r\n\r\n\t\t// This will be the linked-list of all unconsumed edges.\r\n\t\tlet firstEdge = edges[0], lastEdge = edges[edges.length - 1];\r\n\r\n\t\t// Consume an edge:  Remove it from the list, and mark it as 'used'.\r\n\t\tconst consumeEdge = function(edge) {\r\n\t\t\tif (edge.next)\r\n\t\t\t\tedge.next.prev = edge.prev;\r\n\t\t\telse lastEdge = edge.prev;\r\n\r\n\t\t\tif (edge.prev)\r\n\t\t\t\tedge.prev.next = edge.next;\r\n\t\t\telse firstEdge = edge.next;\r\n\r\n\t\t\tedge.used = true;\r\n\t\t};\r\n\r\n\t\t// Find the next edge to follow given a set of possible matches.\r\n\t\tconst findBestPossibleEdge = function(edge, possibleEdges) {\r\n\r\n\t\t\t// Easy degenerate case:  If there's only one edge, take it.\r\n\t\t\tif (possibleEdges.length === 1 && !possibleEdges.used)\r\n\t\t\t\treturn possibleEdges[0];\r\n\r\n\t\t\t// First, prefer following top->right, right->bottom, bottom->left, and left->top,\r\n\t\t\t// if there's a matching edge.\r\n\t\t\tfor (let i = 0, l = possibleEdges.length; i < l; i++) {\r\n\t\t\t\tif (possibleEdges[i].used) continue;\r\n\t\t\t\tswitch (edge.kind) {\r\n\t\t\t\t\tcase 'top':\r\n\t\t\t\t\t\tif (possibleEdges[i].kind === 'right')\r\n\t\t\t\t\t\t\treturn possibleEdges[i];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'right':\r\n\t\t\t\t\t\tif (possibleEdges[i].kind === 'bottom')\r\n\t\t\t\t\t\t\treturn possibleEdges[i];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'bottom':\r\n\t\t\t\t\t\tif (possibleEdges[i].kind === 'left')\r\n\t\t\t\t\t\t\treturn possibleEdges[i];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'left':\r\n\t\t\t\t\t\tif (possibleEdges[i].kind === 'top')\r\n\t\t\t\t\t\t\treturn possibleEdges[i];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// We can't follow our preferred direction, so just take whatever's available.\r\n\t\t\tfor (let i = 0, l = possibleEdges.length; i < l; i++) {\r\n\t\t\t\tif (possibleEdges[i].used) continue;\r\n\t\t\t\treturn possibleEdges[i];\r\n\t\t\t}\r\n\r\n\t\t\t// Shouldn't get here.\r\n\t\t\tthrow new regionError(\"Edge generation failure.\");\r\n\t\t};\r\n\r\n\t\t// Main loop:  We do this until we run out of edges.  Each iteration of the loop\r\n\t\t// will generate one whole polygon.  This whole thing is fairly complex-looking,\r\n\t\t// but it will run in O(n) time.\r\n\t\twhile (firstEdge) {\r\n\r\n\t\t\tconst winding = [];\r\n\r\n\t\t\t// First, find any top edge.  This *could* be up to O(n) in a pathological case, but\r\n\t\t\t// average time is O(1) because of how we generated the edges in the first place.\r\n\t\t\tlet startEdge = firstEdge;\r\n\t\t\twhile (startEdge.kind !== 'top') {\r\n\t\t\t\tstartEdge = startEdge.next;\r\n\t\t\t}\r\n\r\n\t\t\t// Consume and emit the start edge.\r\n\t\t\tconsumeEdge(startEdge);\r\n\t\t\twinding.push({ x: startEdge.x1, y: startEdge.y1 });\r\n\r\n\t\t\t// Now walk forward from the current edge, following its end point to successive\r\n\t\t\t// start points until we reach the startEdge's start point.\r\n\t\t\tlet currentEdge = startEdge;\r\n\t\t\tlet prevX = startEdge.x1, prevPrevX = null;\r\n\t\t\twhile (currentEdge.key2 !== startEdge.key1) {\r\n\r\n\t\t\t\t// First, find the set of possible edges to follow, which should be nonempty.\r\n\t\t\t\tconst possibleEdges = table[currentEdge.key2];\r\n\r\n\t\t\t\t// Move to the edge that is the best one to follow.\r\n\t\t\t\tcurrentEdge = findBestPossibleEdge(currentEdge, possibleEdges);\r\n\r\n\t\t\t\t// Consume it, now that we found it.\r\n\t\t\t\tconsumeEdge(currentEdge);\r\n\r\n\t\t\t\t// Emit the next point in the winding.\r\n\t\t\t\tif (currentEdge.x1 === prevX && prevX === prevPrevX) {\r\n\t\t\t\t\t// This vertical edge was preceded by another vertical edge, so this edge piece extends it.\r\n\t\t\t\t\twinding[winding.length - 1].y = currentEdge.y1;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\twinding.push({ x: currentEdge.x1, y: currentEdge.y1 });\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Record where we've been so we know if we have to extend this edge.\r\n\t\t\t\tprevPrevX = prevX;\r\n\t\t\t\tprevX = currentEdge.x1;\r\n\t\t\t}\r\n\r\n\t\t\t// If the last edge was vertical, and it generated an extra point between its\r\n\t\t\t// start and the winding's first point, remove its extra point.\r\n\t\t\tif (winding[0].x === prevX && prevX === prevPrevX) {\r\n\t\t\t\twinding.pop();\r\n\t\t\t}\r\n\r\n\t\t\t// Finished a whole polygon.\r\n\t\t\tallWindings.push(winding);\r\n\t\t}\r\n\r\n\t\treturn allWindings;\r\n\t},\r\n\r\n\t/**\r\n\t * Calculate a minimal set of nonoverlapping nonadjoining clockwise polygons that describe this region.\r\n\t * The result will be an array of arrays of points, like this:\r\n\t *     [\r\n\t *         [{x:1, y:2}, {x:3, y:2}, {x:3, y:6}, {x:1, y:6}],    // Polygon 1\r\n\t *         [{x:7, y:5}, {x:8, y:5}, {x:8, y:8}, {x:10, y:8}, {x:10, y:9}, {x:7, y:9}]    // Polygon 2\r\n\t *     ]\r\n\t */\r\n\tmakePath = function(array) {\r\n\t\tif (!array.length) return [];\r\n\t\tconst edges = generateEdges(array);\r\n\t\tconst table = makeEdgeTable(edges);\r\n\t\tconst windings = makeWindings(edges, table);\r\n\t\treturn windings;\r\n\t},\r\n\t\r\n\t//---------------------------------------------------------------------------------------------\r\n\t// Region miscellaneous support.\r\n\t\r\n\t/**\r\n\t * Calculate a new region whose coordinates have all been translated/scaled by the given amounts.\r\n\t */\r\n\ttransformData = function(array, ratioX, ratioY, deltaX, deltaY) {\r\n\t\tdeltaX = Number(deltaX);\r\n\t\tdeltaY = Number(deltaY);\r\n\t\tif (!(nInf < deltaX && deltaX < pInf) || !(nInf < deltaY && deltaY < pInf))\t// Catches other NaNs as well as infinities.\r\n\t\t\tthrow new regionError(\"Invalid translation delta\");\r\n\t\tratioX = Number(ratioX);\r\n\t\tratioY = Number(ratioY);\r\n\t\tif (!(nInf < ratioX && ratioX < pInf) || ratioX === 0\r\n\t\t\t|| !(nInf < ratioY && ratioY < pInf) || ratioY === 0)\t\t// Catches other NaNs as well as infinities.\r\n\t\t\tthrow new regionError(\"Invalid scale ratio\");\r\n\r\n\t\tconst newArray = [];\r\n\t\tfor (let i = 0, l = array.length; i < l; i++) {\r\n\t\t\tconst row = array[i]\r\n\t\t\tnewArray[i] = {\r\n\t\t\t\tregion: row.region.transform(ratioX, deltaX),\r\n\t\t\t\tminY: row.minY * ratioY + deltaY,\r\n\t\t\t\tmaxY: row.maxY * ratioY + deltaY\r\n\t\t\t};\r\n\t\t}\r\n\t\t\r\n\t\treturn newArray;\r\n\t},\r\n\r\n\t/**\r\n\t * Determine if the bounding rectangles of each region actually overlap.  If they\r\n\t * don't overlap, we can often treat region operations as special degenerate cases.\r\n\t * This runs in O(1) time.\r\n\t */\r\n\tdoBoundsOverlap = function(data1, data2) {\r\n\t\treturn !(data1.minX > data2.maxX\r\n\t\t\t|| data1.maxX < data2.minX\r\n\t\t\t|| data1.minY > data2.maxY\r\n\t\t\t|| data1.maxY < data2.minY);\r\n\t},\r\n\t\r\n\tcannotConstructMessage = \"Cannot construct a Region2D from \",\r\n\tinvalidRectangleDataMessage = cannotConstructMessage + \"invalid rectangle data.\",\r\n\tinvalidRectangleSizeMessage = cannotConstructMessage + \"a rectangle of zero or negative size.\",\r\n\r\n\t/**\r\n\t * Make region data from a single rectangle, in one of the four major rectangle forms:\r\n\t *     - An object with { x:, y:, width:, height: } properties.\r\n\t *     - An object with { left:, top:, right:, bottom: } properties.\r\n\t *     - An array with [x, y, width, height] values.\r\n\t *     - A DOM element's bounding box.\r\n\t * \r\n\t * This is fairly straightforward, and runs in O(1) time.\r\n\t */\r\n\tmakeRegionDataFromOneRect = function(rect) {\r\n\r\n\t\t// Calculate the actual rectangle coordinates from whatever object was passed in.\r\n\t\tlet minX, maxX, minY, maxY;\r\n\t\tif (typeof(HTMLElement) !== 'undefined' && rect instanceof HTMLElement) {\r\n\t\t\tvar clientRect = rect.getBoundingClientRect();\r\n\t\t\tminX = window.scrollX + clientRect.left, minY = window.scrollY + clientRect.top;\r\n\t\t\tmaxX = window.scrollX + clientRect.right, maxY = window.scrollY + clientRect.bottom;\r\n\t\t}\r\n\t\telse if (isArray(rect)) {\r\n\t\t\tif (rect.length !== 4) {\r\n\t\t\t\tthrow new regionError(invalidRectangleDataMessage);\r\n\t\t\t}\r\n\t\t\tminX = Number(rect[0]), minY = Number(rect[1]);\r\n\t\t\tmaxX = Number(rect[2]), maxY = Number(rect[3]);\r\n\t\t}\r\n\t\telse if (\"left\" in rect) {\r\n\t\t\tminX = Number(rect.left), minY = Number(rect.top);\r\n\t\t\tmaxX = Number(rect.right), maxY = Number(rect.bottom);\r\n\t\t}\r\n\t\telse if (\"x\" in rect) {\r\n\t\t\tminX = Number(rect.x), minY = Number(rect.y);\r\n\t\t\tmaxX = minX + Number(rect.width), maxY = minY + Number(rect.height);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthrow new regionError(invalidRectangleDataMessage);\r\n\t\t}\r\n\r\n\t\t// Validate the rectangle data.\r\n\t\tif (maxX <= minX || maxY <= minY) {\r\n\t\t\tthrow new regionError(invalidRectangleSizeMessage);\r\n\t\t}\r\n\r\n\t\t// Construct the new row containing that rectangle.\r\n\t\tconst region1D = new Region1D([minX, maxX]);\r\n\r\n\t\t// Now make the actual region data for this single-rect region.\r\n\t\tconst data = {\r\n\t\t\tarray: [ {\r\n\t\t\t\tregion: region1D,\r\n\t\t\t\tminY: minY,\r\n\t\t\t\tmaxY: maxY\r\n\t\t\t} ],\r\n\t\t\tcount: 1,\r\n\t\t\tminX: minX,\r\n\t\t\tminY: minY,\r\n\t\t\tmaxX: maxX,\r\n\t\t\tmaxY: maxY,\r\n\t\t\thash: region1D.getHashCode()\r\n\t\t};\r\n\r\n\t\treturn data;\r\n\t},\r\n\r\n\t/**\r\n\t * Construct an empty region consisting of no rectangles at all.\r\n\t */\r\n\tmakeEmptyRegionData = function() {\r\n\t\treturn {\r\n\t\t\tarray: [ ],\r\n\t\t\tcount: 0,\r\n\t\t\tminX: pInf,\r\n\t\t\tminY: pInf,\r\n\t\t\tmaxX: nInf,\r\n\t\t\tmaxY: nInf,\r\n\t\t\thash: 0\r\n\t\t};\r\n\t},\r\n\r\n\trowDataErrorMessage = \"Invalid row data for row \",\r\n\r\n\t/**\r\n\t * Construct a region from raw band data.  This simply checks the band data for correctness,\r\n\t * and then fills in the appropriate metadata.  This runs in O(n) time with respect to the\r\n\t * number of bands.\r\n\t */\r\n\tmakeDataFromRows = function(bands) {\r\n\r\n\t\t// These will collect all the statistical metadata about the region.\r\n\t\tlet prevMax = nInf;\r\n\t\tlet count = 0;\r\n\t\tlet minX = pInf, maxX = nInf;\r\n\t\tlet hash = 0;\r\n\r\n\t\t// Clone the band data, validate it, and collect the metadata.  This is O(n) with respect\r\n\t\t// to the number of bands; the number of rectangles per band is irrelevant.\r\n\t\tconst array = [];\r\n\t\tfor (let i = 0, l = bands.length; i < l; i++) {\r\n\r\n\t\t\t// Check the band.\r\n\t\t\tconst band = bands[i];\r\n\t\t\tif (band.minY < prevMax || band.minY >= band.maxY || !(band.region instanceof Region1D)) {\r\n\t\t\t\tthrow new RegionError(rowDataErrorMessage + i);\r\n\t\t\t}\r\n\r\n\t\t\t// Push a cloned copy of its data.\r\n\t\t\tarray.push({\r\n\t\t\t\tregion: band.region,\r\n\t\t\t\tminY: band.minY,\r\n\t\t\t\tmaxY: band.maxY\r\n\t\t\t});\r\n\r\n\t\t\t// Collect statistics about the band.\r\n\t\t\tconst rowCount = band.region.getCount();\r\n\t\t\tif (!rowCount) {\r\n\t\t\t\tthrow new RegionError(rowDataErrorMessage + i);\r\n\t\t\t}\r\n\t\t\tcount += rowCount;\r\n\r\n\t\t\t// Update the region's X boundaries.\r\n\t\t\tconst bounds = band.region.getBounds();\r\n\t\t\tif (bounds.min < minX) minX = bounds.min;\r\n\t\t\tif (bounds.max > maxX) maxX = bounds.max;\r\n\r\n\t\t\t// Update the region's hash code (for fast inequality tests).\r\n\t\t\thash *= 23;\r\n\t\t\thash += band.region.getHashCode() | 0;\r\n\t\t\thash &= ~0;\r\n\r\n\t\t\tprevMax = band.maxY;\r\n\t\t}\r\n\r\n\t\t// Create the region data from the resulting rows and the metadata.\r\n\t\treturn {\r\n\t\t\tarray: array,\r\n\t\t\tcount: count,\r\n\t\t\tminX: minX,\r\n\t\t\tminY: array.length ? array[0].minY : pInf,\r\n\t\t\tmaxX: maxX,\r\n\t\t\tmaxY: array.length ? array[array.length - 1].maxY : nInf,\r\n\t\t\thash: hash\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Create a simple rectangle from the given region's internal bounding rect.\r\n\t */\r\n\tgetBoundsFromData = function(data) {\r\n\t\treturn {\r\n\t\t\tx: data.minX,\r\n\t\t\ty: data.minY,\r\n\t\t\twidth: data.maxX - data.minX,\r\n\t\t\theight: data.maxY - data.minY,\r\n\t\t\tleft: data.minX,\r\n\t\t\ttop: data.minY,\r\n\t\t\tright: data.maxX,\r\n\t\t\tbottom: data.maxY\r\n\t\t};\r\n\t},\r\n\r\n\t/**\r\n\t * Get a copy of the raw row data.\r\n\t */\r\n\tgetRawRows = function(srcArray) {\r\n\t\tconst destArray = [];\r\n\t\tfor (let i = 0, l = srcArray.length; i < l; i++) {\r\n\t\t\tconst src = srcArray[i];\r\n\t\t\tdestArray.push({\r\n\t\t\t\tminY: src.minY,\r\n\t\t\t\tmaxY: src.maxY,\r\n\t\t\t\tregion: src.region\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn destArray;\r\n\t},\r\n\r\n\t/**\r\n\t * Get all of the rectangle data for this entire region.\r\n\t */\r\n\tmakeRects = function(array) {\r\n\t\tconst result = [];\r\n\t\tfor (let i = 0, l = array.length; i < l; i++) {\r\n\t\t\tconst row = array[i];\r\n\t\t\trow.region.getAsRects(row.minY, row.maxY, result);\r\n\t\t}\r\n\t\treturn result;\r\n\t},\r\n\r\n\t/**\r\n\t * Determine whether this region stretches to infinity in any direction.\r\n\t */\r\n\tisInfinite = function(data) {\r\n\t\treturn data.minX === nInf || data.minY === nInf\r\n\t\t\t|| data.maxX === pInf || data.maxY === pInf;\r\n\t},\r\n\t\r\n\t/**\r\n\t * Compare the Region1D data found in each array instance to each other for equality.\r\n\t */\r\n\tarrayEquals = function(array1, array2) {\r\n\t\tif (array1.length != array2.length) return false;\r\n\t\tfor (let i = 0, l = array1.length; i < l; i++) {\r\n\t\t\tif (array1[i].minY !== array2[i].minY\r\n\t\t\t\t|| array1[i].maxY !== array2[i].maxY) return false;\r\n\t\t\tif (!array1[i].region.equals(array2[i].region)) return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t},\r\n\r\n\t/**\r\n\t * Determine if the data of region1 intersects the data of region2, and do so more efficiently\r\n\t * than simply performing \"!a.intersect(b).isEmpty()\".\r\n\t */\r\n\tdoesIntersectData = function(data1, data2) {\r\n\t\t// TODO: Implement this better than the quick-and-dirty solution below.  Ideally,\r\n\t\t//    this should just test the data and early-out on the first hit, rather than\r\n\t\t//    actually *doing* all the work and then discarding the result.\r\n\t\treturn !!intersectData(data1.array, data2.array).array.length;\r\n\t},\r\n\r\n\t/**\r\n\t * Determine if the given point lies within the given region data.  This first performs\r\n\t * some easy boundary checks, then efficiently finds the matching row (if any), and then\r\n\t * invokes Region1D.isPointIn() to efficiently answer the question for real.  This runs in\r\n\t * O(lg n) time, where 'n' is the number of rectangles in the region.\r\n\t */\r\n\tisPointInData = function(data, x, y) {\r\n\t\tconst array = data.array;\r\n\r\n\t\t// It can't be in the empty set.\r\n\t\tif (!array.length) return false;\r\n\t\t\r\n\t\t// If it's outside the bounds, it's definitely not in.\r\n\t\tif (y < data.minY || y > data.maxY\r\n\t\t\t|| x < data.minX || x > data.maxX) return false;\r\n\t\t\r\n\t\tif (array.length <= 5) {\r\n\t\t\t// Spin over all the rows in a simple linear search.\r\n\t\t\tfor (let i = 0, l = array.length; i < l; i++) {\r\n\t\t\t\tif (y >= array[i].minY && y < array[i].maxY) {\r\n\t\t\t\t\t// Found the row.\r\n\t\t\t\t\treturn array[i].region.isPointIn(x);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Binary search to find the row that y is within.\r\n\t\t\tlet start = 0, end = array.length;\r\n\t\t\twhile (start < end) {\r\n\t\t\t\tconst midpt = ((start + end) / 2) & ~0;\r\n\t\t\t\tconst row = array[midpt];\r\n\t\t\t\tif (y >= row.minY && y < row.maxY) {\r\n\t\t\t\t\t// Found the row, so see if 'x' lies within its spans.\r\n\t\t\t\t\treturn row.region.isPointIn(x);\r\n\t\t\t\t}\r\n\t\t\t\telse if (y < row.minY) {\r\n\t\t\t\t\tend = midpt;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tstart = midpt + 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * Check to ensure that the given object is actually a Region2D, and abort if it is not.\r\n\t */\r\n\tverifyRegion2DType = function(obj) {\r\n\t\tif (!(obj instanceof Region2D)) {\r\n\t\t\tthrow new regionError(\"Object must be a Region2D instance.\");\r\n\t\t}\r\n\t},\r\n\r\n\t//---------------------------------------------------------------------------------------------\r\n\t// Public construction interface.\r\n\t\r\n\t/**\r\n\t * A special private object used to flag internal constructions in such a way that\r\n\t * external callers' data must be validated, but internal data can skip those checks.\r\n\t */\r\n\tprivateKey = {},\r\n\r\n\t/**\r\n\t * Access the internal data, if this is an allowed thing to do.\r\n\t */\r\n\tgetData = function(region) {\r\n\t\treturn region._opaque(privateKey);\r\n\t};\r\n\r\n\t/**\r\n\t * Construct a 2-D region either from either nothing or from the given rectangle.\r\n\t * \r\n\t * Usage:\r\n\t *     var empty = new Region2d();\r\n\t *     var rectRegion = new Region2d(rect);\r\n\t * \r\n\t * The rectangle may be expressed as any of the following three forms:\r\n\t *     - An object with { x:, y:, width:, height: } properties.\r\n\t *     - An object with { left:, top:, right:, bottom: } properties.\r\n\t *     - An array with [x, y, width, height] values.\r\n\t * \r\n\t * Alternative internal invocation:\r\n\t *     var region = new Region2d(regionData, privateKey);\r\n\t */\r\n\tfunction Region2D(rect, key) {\r\n\t\tconst data = (key === privateKey) ? rect\r\n\t\t\t: (typeof rect !== 'undefined') ? makeRegionDataFromOneRect(rect)\r\n\t\t\t: makeEmptyRegionData();\r\n\r\n\t\tthis._opaque = makeProtectedData(data, privateKey);\r\n\t};\r\n\r\n\t/**\r\n\t * The region's prototype contains helpers that simply invoke the private operations\r\n\t * to do all the hard work.\r\n\t */\r\n\tRegion2D.prototype = {\r\n\t\tunion: function(other) {\r\n\t\t\tverifyRegion2DType(other);\r\n\t\t\tconst data = getData(this), otherData = getData(other);\r\n\t\t\treturn new Region2D(unionData(data.array, otherData.array), privateKey);\r\n\t\t},\r\n\t\tintersect: function(other) {\r\n\t\t\tverifyRegion2DType(other);\r\n\t\t\tconst data = getData(this), otherData = getData(other);\r\n\t\t\tif (!doBoundsOverlap(data, otherData))\r\n\t\t\t\treturn empty;\r\n\t\t\treturn new Region2D(intersectData(data.array, otherData.array), privateKey);\r\n\t\t},\r\n\t\tsubtract: function(other) {\r\n\t\t\tverifyRegion2DType(other);\r\n\t\t\tconst data = getData(this), otherData = getData(other);\r\n\t\t\tif (!doBoundsOverlap(data, otherData))\r\n\t\t\t\treturn this;\r\n\t\t\treturn new Region2D(subtractData(data.array, otherData.array), privateKey);\r\n\t\t},\r\n\t\txor: function(other) {\r\n\t\t\tverifyRegion2DType(other);\r\n\t\t\tconst data = getData(this), otherData = getData(other);\r\n\t\t\treturn new Region2D(xorData(data.array, otherData.array), privateKey);\r\n\t\t},\r\n\t\tnot: function() {\r\n\t\t\t// Lazy implementation of 'not': Simply 'xor' with an infinite region.\r\n\t\t\t// A better implementation would take advantage of the efficient Region1d#not() method.\r\n\t\t\tconst data = getData(this), otherData = getData(infinite);\r\n\t\t\treturn new Region2D(xorData(data.array, otherData.array), privateKey);\r\n\t\t},\r\n\t\ttransform: function(scaleX, scaleY, offsetX, offsetY) {\r\n\t\t\tconst data = getData(this);\r\n\t\t\treturn new Region2D(makeDataFromRows(transformData(data.array, scaleX, scaleY, offsetX, offsetY)), privateKey);\r\n\t\t},\r\n\t\ttranslate: function(offsetX, offsetY) {\r\n\t\t\tconst data = getData(this);\r\n\t\t\treturn new Region2D(makeDataFromRows(transformData(data.array, 1.0, 1.0, offsetX, offsetY)), privateKey);\r\n\t\t},\r\n\t\tscale: function(scaleX, scaleY) {\r\n\t\t\tconst data = getData(this);\r\n\t\t\treturn new Region2D(makeDataFromRows(transformData(data.array, scaleX, scaleY, 0, 0)), privateKey);\r\n\t\t},\r\n\t\tisEmpty: function() {\r\n\t\t\treturn !getData(this).array.length;\r\n\t\t},\r\n\t\tisInfinite: function() {\r\n\t\t\treturn isInfinite(getData(this));\r\n\t\t},\r\n\t\tisFinite: function() {\r\n\t\t\treturn !isInfinite(getData(this));\r\n\t\t},\r\n\t\tisRectangular: function() {\r\n\t\t\treturn getData(this).count === 1;\r\n\t\t},\r\n\t\tdoesIntersect: function(other) {\r\n\t\t\tverifyRegion2DType(other);\r\n\t\t\treturn doesIntersectData(getData(this), getData(other));\r\n\t\t},\r\n\t\tisPointIn: function(x, y) {\r\n\t\t\treturn isPointInData(getData(this), Number(x), Number(y));\r\n\t\t},\r\n\t\tequals: function(other) {\r\n\t\t\tverifyRegion2DType(other);\r\n\t\t\tconst data = getData(this), otherData = getData(other);\r\n\t\t\tif (data === otherData) return true;\r\n\t\t\tif (data.hash !== otherData.hash\r\n\t\t\t\t|| data.count !== otherData.count) return false;\r\n\t\t\treturn arrayEquals(data.array, otherData.array);\r\n\t\t},\r\n\t\tgetCount: function() {\r\n\t\t\treturn getData(this).count;\r\n\t\t},\r\n\t\tgetRects: function() {\r\n\t\t\treturn makeRects(getData(this).array);\r\n\t\t},\r\n\t\tgetRawRows: function() {\r\n\t\t\treturn getRawRows(getData(this).array);\r\n\t\t},\r\n\t\tgetBounds: function() {\r\n\t\t\treturn getBoundsFromData(getData(this));\r\n\t\t},\r\n\t\tgetPath: function() {\r\n\t\t\treturn makePath(getData(this).array);\r\n\t\t},\r\n\t\tgetHashCode: function() {\r\n\t\t\treturn getData(this).hash;\r\n\t\t}\r\n\t};\r\n\r\n\t/**\r\n\t * A reusable infinite instance.\r\n\t */\r\n\tRegion2D.infinite = infinite = new Region2D([nInf, nInf, pInf, pInf]);\r\n\r\n\t/**\r\n\t * A reusable empty instance.\r\n\t */\r\n\tRegion2D.empty = empty = new Region2D();\r\n\t\r\n\t/**\r\n\t * Static helper function for creating complex regions from arrays of rectangles.\r\n\t */\r\n\tRegion2D.fromRects = function(rects) {\r\n\t\tif (!rects.length) return empty;\r\n\t\tlet region = new Region2D(rects[0]);\r\n\t\tfor (let i = 1, l = rects.length; i < l; i++) {\r\n\t\t\tregion = region.union(new Region2D(rects[i]));\r\n\t\t}\r\n\t\treturn region;\r\n\t};\r\n\r\n\t/**\r\n\t * Static helper function for creating complex regions from pre-constructed row data.\r\n\t * This is the fastest way to create a complex region, as it runs in O(n) time (with\r\n\t * respect to the number of rows), but it has strict requirements on the shape of the\r\n\t * row data.\r\n\t * \r\n\t * @param rows {Array} - An array of objects, where each object describes a row of the\r\n\t *    region.  The row objects must have the properties 'region' {Region1D}, 'minY' {Number},\r\n\t *    and 'maxY' {Number}.  The 'maxY' of each row must be strictly greater than the 'minY'\r\n\t *    of that row, and the 'minY' of each row must be greater than or equal to the 'maxY' of\r\n\t *    the previous row.  Each row's Region1D must also be nonempty.\r\n\t */\r\n\tRegion2D.fromRawRows = function(rows) {\r\n\t\treturn new Region2D(makeDataFromRows(rows), privateKey);\r\n\t};\r\n\r\n\treturn Region2D;\r\n})();\r\n\r\nexport default Region2D;\r\nexport { Region1D, Region2D, RegionError };\r\n"]}